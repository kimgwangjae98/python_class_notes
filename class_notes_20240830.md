파이썬이랑 머신러닝이랑 다같이 병행할거임(그게 효율적)

오늘부터 본격적으로 배운다!

1교시는 가벼운 내용을 먼저함.

휴먼에러는 사람이 발생시키는 실수들. 사용자입장에선 휴먼에러를 최대한 줄여야됨. 코드의 버그도 휴먼에러임. 정확한 기기사용이 휴먼에러를 줄임. 메타인지(중요한 내용. 이거 없으면 얻어가는 내용이 없음)란… 메타 데이터란 데이터의 데이터임. 메타인지란 인지의 데이터임. 

사람의 의식. 1깜빡이 2차가없음 3차서변경. 메타인지란 1과 2사이를 인지하는것. 사이드랑 백미러 다 봐야됨. 즉, 사각지대를 없애야됨. 뭘 만들려면 이런 과정 하나하나를 인지하고 그 안의 과정도 하나하나 인지해야됨. 사각지대를 숄더체크하거나 사이드미러를 볼록거울로 하기. 기술이 편해질수록 메타인지가 줄어들었기 때문에 메타인지가 중요함. 도구를 맹신하면 안됨. 시스템의 도메인, 프로세스를 이해해야됨. 그러므로 왜? 라고 의문을 들이고 프로세스를 자세히 살펴보고 왜 라고 생각하기. 그만큼 메타인지가 중요함.  뭔 명령받보다는 의문이 있으면 왜 이런걸 했는지 의문을 가지고 살펴봐야됨. 이전에 배운 내용을 적용하냐에 달려있음. 무얼 하더라도 계획(프로세스)를 세워봐야됨. 손으로 계획세우기. 도식도를 그려야 남들보다 이해를 더 잘됨. 남들이 질문했을 때 명확히 답변해줄수 있을 만큼 되야됨.

그러므로 교육받을 동안 메타인지능력을 키워야됨. 궁금증같은거 생각해보기. 그리고 이걸 왜 쓰는지 목적을 생각하기.

메타인지능력 키우는 방법을 찾아보자. 정의같은것도. 유투브 강으도 있으면 찾아보자. 이게 내 개인적인 주말 과제이다. 무조건 수용하기 보다는 의문을 가져보기. 

파이썬 쓰는것도 초보자가 자율주행 만들기 쉬워서 그럼. 라이브러리도 많고 강의도 많거든. 

딥러닝은 이전에 쓰던 알고리즘보다 낫기 때문. 인간이 인지하기 못하는 것까지 인지하는 메타인지 능력을 가지고 있기 때문임. 게다가 일반화 성능이 뛰어나기 때문임. 일반화는 뭐지? 인간이 못하는 것까지 할수있지. 자기가 알아서 특징을 추출하기 때문. 특징 추출이 강점임. 콤볼루션? 그게 특징 추출이래. 이건 뭐지.

룰베이스로 짜는게 딥러닝으로 짜는 것보다 더 빠르고 쉽기도함.

numpy는 선형행렬연산. cpu사용

cupy는 gpu

gpu는 병렬처리함. gpgpu(이건알아보기). 인텔 코어아크, amd 라데온(게임) w(산업. gpu ram 높고 fpu많음) 엔디비아 RTX시리즈, 쿼드로시리즈(1코어를 CUDA) 딥러닝은 세 회사 글카 전부 사용가능. 구글 TPU(텐서플로유닛)도 딥러닝 들어감. 그래픽카드 드라이버를 다룰수 있는 라이브러리가 엔디비아가 가장 최적화 되어있음(딥러닝 가속연산을 엔디비아만 제공함). 그래픽카드 드라이버 다운로드 받을 때 CUDA 드라이버를 다운로드 받고 CUDNN(쿠다뉴럴네트워크. 150% 성능향상. 드라이버 가속기임) 드라이버를 깔아야됨. 엔디비아가 드라이버를 꽉잡고있고 최적화도 안되있고 성능도 딸려서 만들 이유가 없음. 드라이버가 GPU랑 컴퓨터 통신하루 있게 해주고 CUDNN이 딥러닝에 최적화되게 라이브러리를 직접 만짐. 그래픽카드 라이브러리(파일임) 검색해서 조사하기. 파이토치랑 텐서플로가 CUDNN의 라이브러리임(라이브러리의 라이브러리 ㄷㄷ). CUDNN 버전 맞춰줘야 동작함. 요즘은 아나콘다 쓰면 다 맞춰준데. 아나콘다에서 CUDA 라이브러리 지원해준데. 그래서 신경안써도됨. 파이토치는 메타에서 만듬. 파이토치MM이란 라이브러리도 있음. monai란 파이토치 기반 라이브러리있음. YOLO로 파이토치 기반. 파이토치는 버전 올라가도 문법이 잘 안바뀌어서 강사님이 주로 사용한데. 탠서플로는 호환성이 낮음. 그래서 잘안쓴데. 그래픽카드랑 커널에 따라도 호환본데… 텐서플로 미쳤네. 아나콘다는 알아서 적합한 CUDA, CUDNN, 파이썬 라이브러리 검색해서 맞는 버전 설치해줌. 3.10 파이썬 설치해서 써야 안정적임.

라이브러리는 **개발자가 코드를 처음부터 작성할 필요가 없도록 Python 프로그램에 포함시킬 수 있는 자주 사용되는 코드 모음**입니다
GPGPU :  General-Purpose computing on Graphics Processing Units의 머릿글자로, 직역하면 'GPU의 범용 연산’
GPU는 그래픽 프로세스 유닛 화면 처리용 병렬연산에 최적화

NPU는 뉴럴 프로세스 유닛. 신경망 처리용 병렬연산에 최적화

FPU는 플로팅 포인트 유닛.  ***CPU의 일부로서 부동소수점 연산을 효율적으로 처리하기 위한 하드웨어 논리회로 모듈.***  **대형 수학적 연산을 강조하는 명령 집합이 있어서 계산이 빨라질 수 있다**

NPU는 사진 보정 알고리즘에 최적화됨. 이게 폰에 쓰임… 아이폰도 딥러닝 써서 사진보정함. NPU 엄청 돌아감.

산업용은 연산만 하면됨. gpu ram이 많음. 성능은 안좋지만… 블로우타입임. 흡입하고 다른 구멍으로 공기가 나감. 레퍼런스

글카회사에선 칩만 팔고. 그걸 커스텀해서 팔기도함. 직접 칩만드는 회사는 인텔만함. 나노비닝? 이란 기술이 딥러닝 기반임.

그래픽 카드 라이브러리랑 파이썬 라이브러리(라이브러리의 라이브러리)랑 다른거냐.

C언어 기반 GPU다루는 라이브러리, 파이썬 기반 GPU다루는 라이브러리란 차이일 뿐.

게임에도 딥러닝 기술이 들어감. DNSS라고 프레임 늘리는 기법. 안티엘리어싱은 나중에 가르쳐준데. 이런 프레임 늘릴때 딥러닝 기술씀.

CUDA는 프로그래밍, 라이브러리, 드라이버 이름임. 혼동 ㄴㄴ.

글카 12기가 짜리 5개 있어도 12기가 데이터만 처리가능(그냥 분산처리하기 때문). IQ 150 + 150 = 300 아닌거처럼.

라이브러리가 중요하다. 그래픽카드를 다룰 수 있게 해주는 책이다. 

브로드캐스팅이란 기법이 넘파이 핵심 기법. MAT..LIB은 코드로 그래프 그려주는 함수.

쏘가리책 1장 읽어보시고 2장부터 같이 하게됨.

퍼셉트론은 신경망 알고리즘 처음 나온 개념. 노드는 그림에서 동그란거. 레이어가 층. 중간에는 안보여서 은닉층. b는 편향(bias). h(x)는 활성화 함수. w는 가중치. x는 입력. 은닉층이 하나인 퍼셉트론이 단층 퍼셉트론. 은닉층 여러개면 다층 퍼셉트론 = 뉴럴 네트워크. 앞으로 가는게 feed forward(ff) 순전파, 뒤로가는 back propagation 역전파. 역전파는 가중치 업데이트할때 사용. train(=learning. 훈련)은 가중치를 업데이트하는 과정. eval, test, inference는 추론이라고 하며 가중치 업뎃안함. 즉, 순전파에 편미분(gradiant) 안씀. epochs(에폭) 순전파 갔다가 역전파로 되돌아오는 과정 하나를 에폭이라함. 모델이 한번 갔다가 돌아오는 과정(모델관점). 요즘엔 이터레이션이란 말을 씀. 이건 데이터 관점. 데이터 1만개 다쓰면 1만 이터레이션임. 

이터레이션 : 데이터관점. 1데이터 = 1 iter. 1만개 데이터를 5천개(배치 사이즈 5천)만 올림 → 5000 iter. 데이터 라고 기억하면 편함. 요즘 개념마다 의미가 조금 달라서 그래…

에폭 : 모델관점. 순전파 하고 역전파로 되돌아면 1에폭. 에폭도 이터랑 마찬가지로 의미가 조금 다름. 그러니 관점만 보기. 정립이 안되있데. 

요즘엔 이터만 설정한데.

데이터 한 덩이 = 배치. 한번에 밀어넣을 수 있는 데이터 크기. 배치 사이즈도 상황마다 다르다. 웬만하면 배치 사이즈 크면 좋음. 데이터가 크면 데이터의 대표성을 잘 띠기 때문. 표본집단(배치사이즈)이 모집단(전체데이터)을 대표할 수 있는가의 차이. 캐바캐다! 상황마다달라! 변화하는 숫자는 하이퍼 파라미터 라고 함(배치 사이즈).

하이퍼 파라미터는 가중치, 입력, 배치 사이즈 다됨. 물론 가중치 만이라고 하는 경우도 있음(모델만 보여주면). 전부다일경우도 있음(코드 보여주면). 하이퍼란 뜻도 그냥 멋져보일려고 붙였다나~

러닝레이트 : 학습률. 업데이트할 때 얼마만큼 업데이트할건지를 나타내는 숫자. a 비슷한 기호임. learning late(lr. 주로 알파라고 씀) . 가중치 변화량의 증폭도임. 

가장 작은 값은 글로벌 미니멈, 아닌걸 로컬 미니멈. 글로벌이 진짜 있는지 알수없음. 

학습을 fittin 피팅이라고 하기도 함. 우리의 정답과 맞춘다는 의미. 정답-예측 = 손실. 이 손실을 어떻게 구하냐는 손실함수.

과적합하면 일반화 능력이 떨어짐. 물론 과적합을 인위적으로 사용하는 사례도 있음(불량품 검사같은거)

옵티마이저 : 가중치 최적화 알고리즘. 아담만 쓴데.

기본 용어를 그냥 물어보자마자 외울 수 있어야됨. 새로운 용어는 어떻게 할수없네. 그건 설명봐야됨.

인풋(특징)과 아웃풋은 사용자가 직접 설정하는거임. 만약 사진22*22 입력해 22*22사진 나오면 인풋 노드=아웃풋 노드 갯수임.  아웃풋은 자기 마음대로!

원핫벡터 : 0or1임.

ai에서 클래스는 몇 클래스로 나눈다 (종류 나누기랑 같음. 비행기 자동차 자전거를 3클래스. 이름 안붙이면 클러스터링 임). 클래수 갯수만큼 아웃풋 갯수 설정하면 됨. 이거보다 줄이면 클래수 구분이 잘 안됨. 확률이 이상하게 나옴.

라이브러리는 프로그램(파이썬같은거)에서 나타냄. 프레임워크는 하드웨어, 소프트웨어에서 커널 단에서 돌아감.

프레임워크 정의 안됬음. 

2장 코드 따라해보기.

상대경로랑 절대정로 검색해보기.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/914cd412-d6e9-4c46-8afb-88e9c6594671/9940170e-3923-464b-86ab-85c085e94e51/image.png)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/914cd412-d6e9-4c46-8afb-88e9c6594671/27884602-1eb7-4ac0-9fcb-999f6ceeff81/image.png)

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/914cd412-d6e9-4c46-8afb-88e9c6594671/7ce26d00-c08e-4c80-bb50-2426a17c6204/image.png)