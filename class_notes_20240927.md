파이썬은 줄 구분으로 코드를 묶음. 간단한 문법으로 코드를 축약할수 있기도함.
if문에서 가장 중요한 것은 비교할 수 있는 모든 문법이 조건문에 들어갈 수 있음. 물론 그 조건문의 결과는 항상 Ture or False 가 나와됨. 조건문 in은 string에도 쓸 수 있음. 착각 ㄴㄴ. 'p' in "python" -> True 결과 출력. 데이터 검사할 때 쓰임. not in 문도 있음. for in / in 은 다른 용도로 쓰임. for in 은 안에있는걸 하나씩 꺼낼때 쓰임. 반복문이랑 if문을 자주 쓰면 안됨. '속도' 때문임. 조건에 해당하면 ~로 가라. 같이 전에 있던 명령문 주소를 저장해야되서 병목현상이 일어날 수 있음 if문 1번지 실행하고 2번지로 가라 명령하고 그담에 다시 1번지로 간 다음에 3번지로 가라고 주소를 많이 저장해야됨. 그러면 속도가 느려지지. while문은 잘 사용안함. 계속 뺑뺑이 돌릴때 빼면 안써봤데. 그나마 쓰이는 코드가 while 1: 써서 무한반복 시킬 때 씀. break, continue, pass, return 차이가 있음. for문 하나당 break하나로 for문 탈출기임. continue는 그거 만나면 그 뒤에 적힌 코드 다 가지 말고 for문 돌아가란거임. 코드. pass rueturn은 함수에서 쓰이는 코드. break continue는 제어문에 쓰이는 코드. pass는 함수 완성 안되도 오류 안남. 함수 미구현한거 쓸 대 pass씀. if문이랑 for문 속도저하 막기위해 람다 이터레이터 맵 이렇게 기법이 있음. 문제는 이것들 쓰면 남들이 이해를 못함. github에 배운거 올리면 그걸로도 포트폴리오가 됨. linkedin에 올리던 자기 PR를 해야 좋다. 잡코리아 같은 것들도 하면 좋음. 정보를 얻을 수 있기 때문. 

사실 함수가 파이썬의 꽃임. 클래스도 쓰면 좋은데 그건 힘들고. 함수는 어떠한 입력이 들어가면 작업이 됨. 출력이 있을 수 있고 없을 수 있음. 함수는 입력이랑 출력을 무한히 받을 수 있음(c는 하나). return값이 엄청 많이 할 수 있음. 물론 입력이랑 출력이 없어도됨. 웬만하면 아무의미없는 출력을 적음(return 0). 기억하기 : def에서 매개변수를 입력받으면 매개변수가 항상 연결되어있음. 지역변수(임시), 전역변수의 차이임. 입력값이 몇개가 될 지 모르면 어떻게 짜면 될까? 매개변수의 이름을 지정안해주면 집어넣은 순서대로 입력으로 들어감. a=c, b=e 이렇게 지정해주면 순서대로 안써도됨. 웬만하면 입력의 인자를 명시해주면 좋음. 그래야 이해하기 쉬움. 그리고 주석달기. 게다가 입력을 여러개 받을 때는 def(*args) 라고 적으면 무한히 받을 수 있음(def(a, *args) 이렇게 쓸 수 있음. 물론 args는 입력 제일 마지막에 써야됨). 입력한 걸 그냥 args에 갖다넣는걸 많이씀. *은 포인트임. 주소를 가르킨다는거임. *args를 함수 안에서 쓸 때는 args로 씀. 참고로 튜플{}에 담김
예시 ) def(*args) -> def(1,2,3,4,5,6) 를 적으면 args = {1,2,3,4,5,6} 로 사용가능함. 그 예로 for i in args: print(i) 로 사용가능. 계산기 같은 거에 args 사용됨. def(**kwargs)는 def(a=1)에서 사용됨. kwargs = {a:1}. 포인터**가 2개인 이유는 전체{}에 *하나, 각키밸류값마다 *하나 주소를 줘야하기 때문임. 그래서 print(kwargs)로 자주 사용됨. def(name=준기, age= 100) -> {name : 준기, age = 100}. 이건 수강신청 인원 정원같은거, 회원가입에 자주씀. 꼭 *args, **kwargs로 쓰기.

그런데 이렇게 메모리 건들이는 행위가 위험한지 설명함. 메모리 건들이면 해킹의 위험이랑 마찬가지임. 그래서 c가 위험함. rust가 대세이긴해. 조건 걸어서 메모리 관리가 가능하기 때문. 이런 메모리도 garbege collector가 관리함. 파이썬이 이런 기능 있음 일정 시간마다 기능이 작동함.  
참고로 def(a=3) 이렇게 초기값 설정할 수도 있음. 그러면 pirnt(a)하면 3 나옴. 전역변수는 웬만하면 쓰지말기. 메모리잡아먹음. 예외로 global pi=3.14 같이 파이의 연산이 오래걸리면 이렇게씀. 참고로 함수 선언을 많이 해도 프로그램 메모리 많이 잡아먹음. 

클래스는 초보들에게는 이해하기 힘든 개념임. 왜 쓰이는지 알면 매우 좋다. class는 객채 생성자임. class로 객채를 만듬. instance는 객체임. 과자틀과 과자의 관계임. 객채랑 instance는 똑같은 이미임. a=A클래스로 객체 선언하면 a는 class A의 객체라기 보다는 a는 class A의 인스턴스임. 인스턴스는 관계에 더 집중함.  a는 A의 인스턴스, abc는 ABC의 객체. 객체(object)임. 객체지향은 클래스가 있는것을 지향한다고 하는 말임(OOP. ~object program). 사실 이런 객체지향은 필요에 의해 만들어짐. 옛날엔 potran(70년대) / A B C언어가 있었음(B는 visual basic). 이전까지는 객체가 아님. 그래서 유지보수가 안됨. 객체는 유지보수가 용의함. 왜냐하면 재사용(비슷한거 찍어냄. 중요한 장점)이 가능하고 캡슐화(유지보수의 비밀보장. 어렵기 때문)가 가능함. 예시로 자바 파이썬 go C++,C# 등등 요즘 나오는 프로그래밍 언어가  객체지향언어임. 클래스 구성인자는 매서드(함수). 생성자(초기화). 이 두가지임. 생성자에 변수가 포함되어있음 팁임. 구성이 다르긴 함. 
class A()
    def init(self) <- 생성자 : 초기화할 변수들의 집합

    변수들만 들어감...

    def a(self,a ,b ,c) <- 매서드
        self.a = 3
        self.b = 4
    def b()
    def c()
self는 클래스 내에서만 쓰인다는 뜻임. '틀'이란 뜻. self를 명시적으로 적어줌. 매서드는 객체가 아님. 함수는 (a= def k)이 가능. 있는 그대로 쓸 수 있음. 그냥 외워. self써줘야 함수를 만들 수 있는 객체다 라고 알려주는거임.  

딥러닝에 잘 씀. 데이터로더, 모듈, 학습, 평가 클래스 4개만 있음 파이토치에.

상속(inheritance)과 덮어쓰기(overiding)의 차이점. 상속은 class A(상속이나 overclass)임. 그냥 가져다 쓰는거임. 덮어쓰기는 메서드 이름 같고 그거 편집하는거임(상속필수). a=A , a.A 에서 . 은 속성이란 뜻 A는 a의 속성, a는 A의 속성을 가지고있다. 클래스는 여러번 봐야됨.   