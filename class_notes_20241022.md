발표 - 무슨 센터에서 발표함. 기업들과 면접을 봄. 거기서 붙으면 취직임. B반이랑 같이할수도있음. 발표는 이수 마지막 주에 예정. 프로젝트 시작 직전에 발표함. 소프트웨어 프로젝트는 4명 단위로 예정. 로봇같은경우 반 전체가 참여할 예정. 공유자재는 같이 쓸 수 있음. 프로젝트 진행도중 추가 부품 주문도 허용됨(이백만 이하)
10.23 휴강.
11 20~22일 휴강.

넘파이는 성형대수를 쉽게 풀어주는 계산 라이브러리임. 선형대수는 신경망의 효율적인 계산을 위해 풀어줌. 신경망이 행렬로 이루어진 것도 있고.
넘파이 배열에서 배열=행렬=벡터. 얕은 복사와 깊은 복사는 진짜 말 그대로임. 중요하게 볼 것은 브로드 캐스팅. 오픈cv로 이미지 다루는 4챕터 공부함. 넘파이로 가능한데 복잡해서 오픈cv로 간단하게 구현 가능함. 챕터 5까지 공부하고 챕터 6은 나중에 할것임.
파이썬은 3.11 버전 사용을 권장함. 파이토치,텐서플로가 최신 버전 3.12를 지원 안해. 버그가 있어서 그래. 넘파이는 버전이 1,2로 나뉨. 우리가 평범하게 넘파이 설치하면(서버에) 2.1.1 버전이라고 뜨네. 1,2 버전 차이는 데이터 타입에서의 차이임.
1바이트=1개 문자 = 8비트
8비트로 영어를 전부 표현가능함. 1 바이트는 256개의 명령어를 만들 수 있고 bit로 읽으면 너무 작아서 때문에 명령어를 만들 수 있는 최소 크기로 1 바이트로 설정함.
32비트=4바이트
32비트 운영체제는 4기가 바이트
bit = 2^n
byte = 2^3
kilobyte = 2^10
megabyte = 2^20
gigabyte = 2^30 -> 2^32 = 4*2^30 = 4기가 바이트
즉 32비트 운영체제의 명령어 총 용량은 4기가이고, 이는 램 용량도 4기가가 최고란 의미임. 이는 명령어 갯수만큼 cpu가 최대로 처리가 가능하다. 게임할때 이 문제가 있었지.
64비트 운영체제의 명령어 총 용량은? = 2^64개.
테라,패타,엑사바이트-2^40,50,60으로... 64비트 운영체제는 16엑사바이트 만큼 메모리를 인식할 수 있다. 실제로 2^64개의 명령어가 있진 않아... 최대로 2^64개 만들 수 있는 것 뿐.
대만 미디어택 cpu = 시멘시티, 미디어택 (그거 무선 와이파이 꽃게모양 그거...) arm 오라이온이라고 risc cpu 8개 박아서 성능을 향상시킴. 집적도 향상, 소비전력 감소, 발열 반토막, 성능 2배 향상

메모리에 올라가면 버퍼라고함.
max,min,sum,mean 같은 경우 차원상관없이 최소최대평균들 다 구함.
c.sum(axis=1) 로 1차원으로 합을 구할 수 있음.
axis=0 은 행, axis=1 은 열. 01=행렬.
행은 세로줄이 한개.
열은 가로줄이 한개.
123
456
789
첫번째행 123
두번째행 456
세번째행 789
->3행
첫번째열 147
두번째열 258
세번째열 369
가로는 행
세로는 열
가로줄의 갯수 = 열의 갯수
세로줄의 갯수 = 행의 갯수
헷갈리지 말기!
가열-줄
xyz이면 120 axis임을 기억할 것
어쨌든 넘바이 배열이 파이썬 리스트보다 더 빠르다. 왜냐하면 넘파이가 램을 효율적으로 활용하기 때문.
1차원 배열 사용시 주의점은 출력이 (n,)로 나온다는점임. 수학적으로는 (n,1)임. 그렇지만 (n,)!=(n,1) 임. 중요한건 현태는 둘 다 동일한다는 점임. 파이토치랑 넘파이랑 일차원 배열의 형태가 달라서 오류가 날 수 있음. 파이토치에 쓸려면 (n,)를 (n,1)로 바꿔줘야됨. 표기법만 다른데 그것때문에 오류가 나지.
np.empty 는 최대한 0에 가까운 값이 나오고(float) np.random은 0~1사이 값을 무작위로 할당함. np.zeros는 0으로 할당(int). randint는 주어진 범위 내에서 무작위 정수값을 할당함.

면접에선 대체로 이런 문제가 나옴
1. print(0.1+0.2)=0.3인가?
2. np.zeros와 np.empty의 출력의 차이에 대해서 설명하시오

1. 먼저 소수점의 2진수 표현법에 대해 알아야 한다. 대체로 0.5 = 0.1 이란 이진수로 표현되고 0.25 = 0.01로 표현된다. 그런데... 0.1,0.2,0.3은 이렇게 딱 맞아 떨어지는 숫자가 나오지 않는다. 그리고 0.1과 0.2를 더해 0.3을 만들어도 이건 덧셈 연산을 한 후 마지막 소수점 자릿수를 반올림을 해서 구하기에 실제 0.3과 다른 값이 나온다.
https://man-wol.tistory.com/entry/01-02-03-false

0.1을 이진수로 어떻게 나타낼까?
-> (부호) *  significant * 2^exponent
소수 7514 = 7.514*10^3 이렇게 '부동연산' 으로 나타낼 수 있다.
7.514 : coefficient. 계수
10 : basenumber. 진수(이진수할때 그거)
3 : exponent. 지수
여기서 바뀌는 값은 계수와 지수.
계수는 1보다 크거나 같고 진수보다 작다.
부동은 움직이지않는 이란 뜻이 아니라 떠다닌다는 뜻임(부력의 부). => floating point = 부동 소수점. 즉슨, 점이 움직인다는 뜻.

부호 * 가수 * 밑수^지수 
위 식은 실수의 표현 방법임
sign
significand
basenumber
exponent
이런 표현방법을 정규화 라고 함. 왜 쓰냐면 이진법 표현이 용이해서 그럼
컴퓨터는 IEEE 규격으로 을 표현함
1bit는 부호
8비트는 지수
23비트는 가수
0.011 를 이진수로 정규화 시키면 
0.911 = (+1) * 1.1 * 2^-3
부호 : +
가수 : 1.1
지수 : -2

bias=127. 이게 있는 이유가 양수음수 둘다표현할려고 그럼.
(-2)지수+(-127)bias= 125

1   1111    1111
1   0111    1101    10000...000     + 125 
부호    지수            가수
+       -2          1
가수의 범위 = 1 <= 가수 < 밑수(항상1보다크다)

0.1 => 0.000110011001100110011
1   0111    1101    1001    1001    1001    1001    

0.000110011... -> 1.1001100 * 2^-4
-4 + 127 = 123, 11001100에서 앞에 1은 무조건 들어가니 때버림. 10011001100
즉슨 0.1은
1   0111    1011    1001100110011001100
즉슨 0.2은
1   0111    1001    1001100110011001100
0.0001100110011001100...
0.0011001100110011001...
더해도면 반올림 때문에 마지막 비트가 0이 된다
실제 003과 0.1+0.2는 마지막 1비트가 다르기에 같은 숫자가 아니다.

2. 이거는 그냥 정수형으로 0을 출력하는지, 부동소수점으로 0을 출력하는지 이다. 아니네, zeros는 배열 초기화된 0을 할당하고, empty는 초기화 안하고 값을 할당한다. 이 경우 쓰레기값이 할당될수도있다. 메모리 공간만 할당하는거지.
https://firework-ham.tistory.com/33

zeros는 0으로 초기화를 진행하기에 속도가 느리고 empty는 0으로 초기화 안하고 부동소수점으로 0에 가까운 소수점을 표현하기 빠르다.

np.linespace는 range랑 비슷하게 배열을 만들어줌

shape 변환 함수는 중요함. reshape 함수인데, 이 함수는 배열의 형태를 바꿔준다. reshape는 배열의 갯수가 정수의 곱셈 형태로 나오게 하는 형태가 아니면 쓸 수 없다. 8 = 1*8, 2*4, 4*2, 8*1 이렇게. 이건 2차원이었고 3차원이면 경우가 더 많아짐. 배열들은 순서대로 reshpae됨. 처음에 토막내고 다음걸로 반도막씩 그렇게 나눔.
:콜론의 뜻 : ~부터 ~까지. [:] 는 전체

얕은 복사는 변수만 생성한 다음에 원본 배열의 주소안에 있는 값들을 가져옴. ex:reshape, asarray
깊은 복사는 원본배열을 복사한 다음 변경시킴. ex:reval, array
이런 복사는 넘파이 배열일 때만 성립함.