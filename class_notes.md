"# python_class_notes"  
파이썬은 프로그래밍 언어임. 남이 쓰던 코드 가져와서 편하게 쓸수있고 남들과 협업도 할수있음. 인간이 이해하기 쉬워서 컴퓨터가 이해하기엔 어려워 개발속도는 빠르나 작업속도는 느림. 아나콘다는 파이썬 버전 관리 + 라이브러리 관리를 함. 라이브러리는 남들이 짠 코드 모음으로 다른 사람들이 쓰기 편하게 만들어둔 코드임. 사용할 때는 import xxx 로 씀. xxx 라는 라이브러리를 데려온다는 뜻. 라이브러리는 bin/lib/xxx.py 형태로 존재함. 파이썬은 bin/python으로 존재하고. 직접 라이브러리를 복사붙여넣기 등 관리하기 불편하기 때문에 pip(package installer python)이라고 파이썬 라이브러리관리자를 씀. 다운받은 파일(wheel)을 압축해제하고 컴파일해서 지정된 위치(biallib)에 위치시킴. 가끔 c+파이썬 같이 쓴 혼종 코드가 있음. 파이썬은 glue 언어라고 c랑 호환됨. cpython이라고 c랑 파이썬 문법을 다 쓸 수 있음. c언어로 짠 라이브러리도 있음(numpy). wheel은 파이썬 라이브러리 압축확장자임. 라이브러리 잘 쓸수있도록 잘 굴러간다고... 라이브러리 받을 때 컴파일 하기도 하고 안하기도 한다네. 라이브러리들은 pypi.org라는 도서관에 위치함. 의존성(버전에 따른 파일 변화)이 있음. 버전마다 될때도 있고 아닐때도 있음. wheel 파일에는 의존성 파일 목록도 있음. 가끔 wheel 파일을 직접 검색해서 다운받는 방법이 더 편할 수 있음. pip도 라이브러리임 참고해. wheel 라이브러리도 있다... 이게뭐야. 어쨌든 과정을 배웠음. 나중에 pip 에러나도 라이브러리 설치할 수 있음. 가끔 라이브러리 위치를 import /xxx/xx... 처럼 경로 넣어서 라이브러리 사용할 수 있음. 파이토치는 라이브러리가 너무 커너 pip install pythorch ......-index www.akdflaf... 이렇게 주소 적어서 씀. 가끔 돈주고 파는 라이브러리도 있음. 기본라이브러리도 너무 많아서 이렇게 라이브러리 형식으로 깔림. 남에서 빌려다 쓴경우 많아서도 그렇다네. 파이썬 컴파일러 이름은 파이썬임. c언어는 gcc tcc 등 컴파일러 종류가 많음. 우리가 직접 컴파일러 만들 수 있음. 파이썬 3.11.9 이렇게 보면 파이썬 버전이 컴파일러종류임 잊지말것. 파이썬 컴파일 명령어는 python /ddd/...경로 작성해주면 컴파일됨. 컴파일러는 코드 전체를 보고 해석, 인터프리터는 한줄식. 파이썬은 인터프리터, 컴파일러 둘 다 가능. 컴파일러는 경로 넣어 명렁. 인터프리터는 python이거임. 그냥 python 명령어 치면 파이썬 인터프리터가 실행됨. 나가는건 exit(). 참고로 .py 로 작성해야 파이썬 문법 검사기가 작동함.  원하는 대로 코드 실행시킬려면  ipythonnotebook->jupyternotebook (ipynb) - gui라서 colab기능 가능. 느린데 내 데이터 확인용으로 효과적임. 출력을 파일에 불러와줌. 코드 실행하면 바로 밑에 이미지를 보여주지. i는 인터프리터 의미. 그러니 코드 짤때는 ipynb로 하고 학습을 python으로 해야 효과적임. ipynb은 컴파일러가 계속 실행되어있음(이전에 실행 코드 기록이 계속 남아있음). python은 컴파일러가 한번만 실행됨. 그래서 ipynb은 import 안했는데도 실행이 되는구나. 재생 버튼 누른거는 터미널에 python ~~~경로 쳐주는 거일뿐임. 그래서 play대신 터미널에 치라고 하는거임. 우리가 보는 서버에서 만든 이미지는 사실 서버에서 이렇게 화면을 구성해라 라고 데이터를 주고 로컬에서 그 데이터를 받아 화면에 띄움. 즉 컴파일은 서버에서하고 그 출력은 로컬에서 시킴. 

우리가 콘다 가상환경을 왜 쓰냐면 가상환경을 써야 개발환경 구축이 편리하고 관리가 쉬워지며 개발환경 공유가 쉽기 때문임. 게다가 콘다는 우리가 공부하는 머신 러닝 작업에 유용한 라이브러리들이나 패키지들과 환경을 쉽고 효율적으로 관리할 수 있기 때문임.
파이썬 문법은 안가르쳐주니까 알아서 하고. 무엇을 어디에 어떻게 쓰는지 알려준다고함. 전공자에게 기대가 큰 만큼 실력을 쌓아야 할 것임.
유틸리티란 뭘까? 번역하면 '도구'임. 파이썬은 시스템 유틸리티. 파이썬은 컴파일러를 통해 시스템이 이해할 수 있는 언어로 만들어버림. 라이브러리가 존재함. 파일 만들고 쓰는 것도 유틸리티 이용한거임. 대표적인 라이브러리가 os. 
a=op.path(경로) 이게 유틸리티의 예시지. 경로를 컴퓨터가 이해하게 바꿔줌. a에 경로가 담기는 거지. 
참고로 파이썬은 오른쪽부터 왼쪽으로 읽음(for i in range 처럼) 
gui는 그래픽 유저 인터페이스임. 이쁘게 만들어줌. 예시로 팅커. 파이큐티
c랑 결합하는 glue. 이거덕에 많이 좋아짐
웹도 만들수 있음. 화면에 보이는 웹화면이 프론트엔드임. 날려준 정보로 화면을 컴퓨터가 구성함. 정보 날려준 곳이 백엔드. 특히 Flask 라이브러리가 필요함. 음 이거면 충분할... 한국은 자바쓴다네; 스타트업에서 자주 flask 주로 쓴데. streamit 라이브러리는 무료로 도메인 만들어줌. 개꿀임. 베타프로그램 만들기 좋음. 문법이 이상하데. 이거로 웹개발하자! 
numpy의 num은 선형대수(linear algebra. 선형 방정식)를 의미함. 선형대수 계산에 효과적이다. 왜 선형대수가 많이 쓰이냐면... 선형대수는 연산이 복잡함. 연산을 병렬로 처리할 수 있음(마치 모니터 픽셀 병렬 연산 gpu처럼). 그러므로 다중병렬연산처리에 특화되어있음. cupy(cuda+numpy)도 있음.
데이터베이스 프로그래밍도 있음. DB는 무형의 공간임. ssd 내에 DB 영역이 있는거지. 256GB에서 120GB를 DB로 쓰겠다는 식. DB에도 종류가 있음. mariadb, mysql, oracle(유료)... 라이브러리가 있음. 크롤링 데이터를 저장하는데 좋겠네. 자율주행 지도 저장을 DB에 하기 때문에 배움. 파이썬을 이것들을 제공하고. 라이브러리들도 DB가 제공한 주소를 받아서 씀. 
pandas 라이브러리는 엑셀 쉽게 다루는 라이브러리임. 
자료형은 그냥 배우고 넘어가는 경우가 많음. 숫자 3을 문자로 표현하면 0x11 문자열 인코딩이 발생함. 우리나라는 ko,kr, UTF-8을 씀. 글자 깨지는 현상은 대체로 인코딩 오류임. 문자열, 정수형, 소수점, 16진법 등이 있음. 파이썬은 컴파일러가 알아서 판단해줌(그래서 좀 느림). mojo.fire 도 자료형 지정해주면 빨라짐. 지정해줄때도 오른쪽에서 왼쪽으로. 그래서 a=3을 3을 a에 담는다 라고 표현함. 문자열 자료형은 독특함. ",' 있으면 문자열로 인식함. "'abcde'" 는 0123456임 위치가. 인덱싱 위치 자료가 전부 포함되어있음. 이스케이프 코드는 인코딩 처럼 문자열에 포함되지 않는 코드. 스페이스나 엔터 쌍따옴표같은거. NULL,  , 0 은... NULL 공간은 있는데 내용이 없음.   '  '은 공간도 없고 내용도 없음. 0은 공간은 있는데 내용이 있긴한데 그 흔적이 남은거. 휴지걸이에 휴지심이 있는거, 아예없는거, 휴지심에 종이쪼가리 붙은거로 대충 설명 가능함. NULL은 자주쓰면 안됨. 시스템 에러가 남. 가능한 자제하자. 뭔가를 반환해야 에러가 안나는데 NULL은 반환이 안됨. NULL처럼 주소만 있으면 안된디야. 데이터가 어떤건지 알수가 없음. 리스트는 자료집합으로 쓸 때, 여러개의 자료형 모을 때 자주씀. 튜플은 중요한 데이터, 변환하면 안되는 데이터 담을 때 씀. 주로 처음 데이터 받을 때 튜플을 씀. 물론 이것보다 딕셔너리가 유용하기에 자주 안씀. 튜플은 불변이다. 리스트는 변함. 딕셔너리는 key, value가 여러개 각각 묶여서 있음. value로 key를 못찼음. 그러니 key랑 value 뒤집어서 내면 좋음. 이거 key value 뒤집는 함수 만들어보기. 집합형은 몰라도됨. 불형은 이미지에 잘 씀. 이미지 겹치면 ture, 아니면 false. 아님  특정 자리에서 원하는 데이터 얻을 때 씀. 값을 마스킹(칠한다)하는데 잘 사용함. false*정수 = false, true*정수 = 정수. 참과 거짓은 다 외우기. 조건문이나 for문에 쓰기 때문에 알아야함. NULL은 아무것도아님(false취급도 하기도함). 그림에서 사람 얼굴만 뽑아내는걸 불형식으로 쉽게함. 2차원 좌표 2차원 리스트에서 특정 공간을 뽑아낼려면 그냥 불형으로 전체랑 좌표 곱하면 됨. 그러면 쉽게 뽑아냄. for문은 리소스 많이 잡아먹음. 왜냐하면 for문은 이전에 코드 주소를 미리 저장해둔걸 이용해 반복을 돌수있음. for문 다중으로 만들면 주소를 많이 잡아먹음. 이전 메모리 주소를 계속 기억을 해야되기 때문임. 계속 메모리 주소 서칭하는데도 시간이 오래 걸림. 이걸 왜 배우냐면 우리 자율주행이 시스템 메모리까지 다루기 때문임. 그래서 속도가 생명. 
파이썬은 줄 구분으로 코드를 묶음. 간단한 문법으로 코드를 축약할수 있기도함.
if문에서 가장 중요한 것은 비교할 수 있는 모든 문법이 조건문에 들어갈 수 있음. 물론 그 조건문의 결과는 항상 Ture or False 가 나와됨. 조건문 in은 string에도 쓸 수 있음. 착각 ㄴㄴ. 'p' in "python" -> True 결과 출력. 데이터 검사할 때 쓰임. not in 문도 있음. for in / in 은 다른 용도로 쓰임. for in 은 안에있는걸 하나씩 꺼낼때 쓰임. 반복문이랑 if문을 자주 쓰면 안됨. '속도' 때문임. 조건에 해당하면 ~로 가라. 같이 전에 있던 명령문 주소를 저장해야되서 병목현상이 일어날 수 있음 if문 1번지 실행하고 2번지로 가라 명령하고 그담에 다시 1번지로 간 다음에 3번지로 가라고 주소를 많이 저장해야됨. 그러면 속도가 느려지지. while문은 잘 사용안함. 계속 뺑뺑이 돌릴때 빼면 안써봤데. 그나마 쓰이는 코드가 while 1: 써서 무한반복 시킬 때 씀. break, continue, pass, return 차이가 있음. for문 하나당 break하나로 for문 탈출기임. continue는 그거 만나면 그 뒤에 적힌 코드 다 가지 말고 for문 돌아가란거임. 코드. pass rueturn은 함수에서 쓰이는 코드. break continue는 제어문에 쓰이는 코드. pass는 함수 완성 안되도 오류 안남. 함수 미구현한거 쓸 대 pass씀. if문이랑 for문 속도저하 막기위해 람다 이터레이터 맵 이렇게 기법이 있음. 문제는 이것들 쓰면 남들이 이해를 못함. github에 배운거 올리면 그걸로도 포트폴리오가 됨. linkedin에 올리던 자기 PR를 해야 좋다. 잡코리아 같은 것들도 하면 좋음. 정보를 얻을 수 있기 때문. 

사실 함수가 파이썬의 꽃임. 클래스도 쓰면 좋은데 그건 힘들고. 함수는 어떠한 입력이 들어가면 작업이 됨. 출력이 있을 수 있고 없을 수 있음. 함수는 입력이랑 출력을 무한히 받을 수 있음(c는 하나). return값이 엄청 많이 할 수 있음. 물론 입력이랑 출력이 없어도됨. 웬만하면 아무의미없는 출력을 적음(return 0). 기억하기 : def에서 매개변수를 입력받으면 매개변수가 항상 연결되어있음. 지역변수(임시), 전역변수의 차이임. 입력값이 몇개가 될 지 모르면 어떻게 짜면 될까? 매개변수의 이름을 지정안해주면 집어넣은 순서대로 입력으로 들어감. a=c, b=e 이렇게 지정해주면 순서대로 안써도됨. 웬만하면 입력의 인자를 명시해주면 좋음. 그래야 이해하기 쉬움. 그리고 주석달기. 게다가 입력을 여러개 받을 때는 def(*args) 라고 적으면 무한히 받을 수 있음(def(a, *args) 이렇게 쓸 수 있음. 물론 args는 입력 제일 마지막에 써야됨). 입력한 걸 그냥 args에 갖다넣는걸 많이씀. *은 포인트임. 주소를 가르킨다는거임. *args를 함수 안에서 쓸 때는 args로 씀. 참고로 튜플{}에 담김
예시 ) def(*args) -> def(1,2,3,4,5,6) 를 적으면 args = {1,2,3,4,5,6} 로 사용가능함. 그 예로 for i in args: print(i) 로 사용가능. 계산기 같은 거에 args 사용됨. def(**kwargs)는 def(a=1)에서 사용됨. kwargs = {a:1}. 포인터**가 2개인 이유는 전체{}에 *하나, 각키밸류값마다 *하나 주소를 줘야하기 때문임. 그래서 print(kwargs)로 자주 사용됨. def(name=준기, age= 100) -> {name : 준기, age = 100}. 이건 수강신청 인원 정원같은거, 회원가입에 자주씀. 꼭 *args, **kwargs로 쓰기.

그런데 이렇게 메모리 건들이는 행위가 위험한지 설명함. 메모리 건들이면 해킹의 위험이랑 마찬가지임. 그래서 c가 위험함. rust가 대세이긴해. 조건 걸어서 메모리 관리가 가능하기 때문. 이런 메모리도 garbege collector가 관리함. 파이썬이 이런 기능 있음 일정 시간마다 기능이 작동함.  
참고로 def(a=3) 이렇게 초기값 설정할 수도 있음. 그러면 pirnt(a)하면 3 나옴. 전역변수는 웬만하면 쓰지말기. 메모리잡아먹음. 예외로 global pi=3.14 같이 파이의 연산이 오래걸리면 이렇게씀. 참고로 함수 선언을 많이 해도 프로그램 메모리 많이 잡아먹음. 

클래스는 초보들에게는 이해하기 힘든 개념임. 왜 쓰이는지 알면 매우 좋다. class는 객채 생성자임. class로 객채를 만듬. instance는 객체임. 과자틀과 과자의 관계임. 객채랑 instance는 똑같은 이미임. a=A클래스로 객체 선언하면 a는 class A의 객체라기 보다는 a는 class A의 인스턴스임. 인스턴스는 관계에 더 집중함.  a는 A의 인스턴스, abc는 ABC의 객체. 객체(object)임. 객체지향은 클래스가 있는것을 지향한다고 하는 말임(OOP. ~object program). 사실 이런 객체지향은 필요에 의해 만들어짐. 옛날엔 potran(70년대) / A B C언어가 있었음(B는 visual basic). 이전까지는 객체가 아님. 그래서 유지보수가 안됨. 객체는 유지보수가 용의함. 왜냐하면 재사용(비슷한거 찍어냄. 중요한 장점)이 가능하고 캡슐화(유지보수의 비밀보장. 어렵기 때문)가 가능함. 예시로 자바 파이썬 go C++,C# 등등 요즘 나오는 프로그래밍 언어가  객체지향언어임. 클래스 구성인자는 매서드(함수). 생성자(초기화). 이 두가지임. 생성자에 변수가 포함되어있음 팁임. 구성이 다르긴 함. 
class A()
    def init(self) <- 생성자 : 초기화할 변수들의 집합

    변수들만 들어감...

    def a(self,a ,b ,c) <- 매서드
        self.a = 3
        self.b = 4
    def b()
    def c()
self는 클래스 내에서만 쓰인다는 뜻임. '틀'이란 뜻. self를 명시적으로 적어줌. 매서드는 객체가 아님. 함수는 (a= def k)이 가능. 있는 그대로 쓸 수 있음. 그냥 외워. self써줘야 함수를 만들 수 있는 객체다 라고 알려주는거임.  

딥러닝에 잘 씀. 데이터로더, 모듈, 학습, 평가 클래스 4개만 있음 파이토치에.

상속(inheritance)과 덮어쓰기(overiding)의 차이점. 상속은 class A(상속이나 overclass)임. 그냥 가져다 쓰는거임. 덮어쓰기는 메서드 이름 같고 그거 편집하는거임(상속필수). a=A , a.A 에서 . 은 속성이란 뜻 A는 a의 속성, a는 A의 속성을 가지고있다. 클래스는 여러번 봐야됨.   

모듈은 클래스들의 집합. 그런데 import 해올수 있는 모든 파일들은 모듈이라고 칭함. import는 파이썬에서 '가져오다'란 뜻임. import로 라이브러리 가져옴. 그냥 파이썬 파일안에 있는거 모듈임. import numpy as np는 numpy가 라이브러리 있는 경로이고, 이 경로는 환경변수임. 환경변수는 내가 어디에 있든지 간에 여기에 있는건 반드시 찾는다. 내가 찾고자 하는 곳이 등록되어 있다는 뜻. 거진 여기부터 찾아봄. numpy.array하면 numpy모듈의 array 함수를 가져온다는 뜻. .py는 빼는데, 파이썬 파일을 컴파일 해서 보느냐, 컴파일된 파일을 가져와서 볼 수 있어서 달라서 .py뺌. 모듈이름 겹치치않게 쓰자 안그럼 이전에 있던 모듈에 오버라이딩됨. 환경변수가 있어서 파일 제목만으로 찾을 수 있음. 시스템 환경 변수 편집 을 윈도우에 검색하면 나옴. 유저만, 시스템 전체에 적용되는 환경변수로 나뉘어 등록되어있음. 리눅스면 /bashrc 파일에 'export 변수명=경로' 작성해두기. 그러면 환경변수 설정됨. bash 하면 $abcd에 호나경변수 주소가 들어가는거지. from '경로' import '함수 or class'. from math import sin -> sin 쓰면됨. 원하는 함수만 불러옴. import math -> math.sin() 이렇게 씀. 파일이 여러개 겹쳐져 있다면 from 뒤에 import 할 때 ~~.~~.~~~...~~. 으로 하면 맨 마지막에 있는거(함수 or 클래스) 쓸수있음. from ~~>~~.~~.~~ import 함수 이렇게 써도 됨. import 다음엔 경로가 온다고 기억하기. 우리가 쓰는 그냥 라이브러리 이름은 환경변수가 이미 컴퓨터에 등록되어 있기 때문에 이름만 써도됨. 

if __name__=="__main__"
는 아래 코드들 실행안함. 모듈에선 실행이 안되고(import되니 파일에 이거 적어봐도 이거 작동안함) 직접 실행하는 파이썬 파일에 적으면 실행됨. if __name__=="__main__": printa() 하면 import 할 때 printa()는 실행안됨. 

패키지는 모듈들의 집합. 라이브러리=패키지. 파이썬 파일들의 집합이란 뜻이기도함. 패키지가 엄청 많아지면 프레임워크. 파이토치는 프레임워크라 불러달래서 프레임워크. 패키지 쓸려면 예시로 import pytorch.nn.class 이렇게 쓰면 됨. from torch.nn.class import classA 이렇게 쓰면 클래스 불러와서 쓸 수 있음.  __init__.py는 생성자와 똑같음. 폴더 하나당 한개임. pytorch, nn, vision에 하나씩 있음. 옛날엔  하나씩 적어줘서 명시를 해줬어야했음. 변수 초기화 설정할때도 씀.

복습
모듈 : 클래스들의 집합, 파이썬 파일 하나, 
패키지 : 모듈들의 집합, 생성자가 포함되어있음. 패키지에서 생성자(init.py)는 길잡이를 말함. 각 폴더마다 써움으로써 이 폴더는 패키지다 라고 선언해줌. 생성자 안써도 되는데, wheel이란 내장함수에 경로만 적어주면 알아서 만들어주기 때문임. 그런데 왜 생성자를 포함하는게 좋다고 하느냐? 상위폴더에 있는 파이썬 파일 import 할려하면 import ..printA.py 이런식으로 점 두개를 받아야됨. 오류가 나기도 하는데 왜 그러냐? 터미널에서 사용자 위치가 요상한데 잡혀있기 때문임. 터미널의 사용자 위치를 잘 봐두어야됨. 요즘엔 이렇게됨. 이걸 방지하기 위해서는 생성자(init.py)에서 경로를 초기화 하는 방법이 있음. 내가 상대위치를 파이썬 코드로 줄수있음. os.chdir('경로'). 이걸로 경로를 바꿀수있음. os.pwd() 하면 지금 내 위치 경로를 출력함. 이해못할 수 있는데, 터미널 위치 기준을 잘 보기. 주피터노트북은 위치가 이상한데 잡힐 수도 있으니 상대경로는 자제해야할것. 쓸거면 os.chdir()쓰기. 터미널 기준인데 자기 위치 잘 알아야됨. 이런걸 왜 말하는가? 경로를 지정해줬는데 안되. 알고보니까 폴더이름이랑 파이썬 파일 이름이 똑같아서 폴더를 찾을지, 파이썬 파일을 찾을지 분별을 못하기 때문임. 웬만하면 파일 이름은 복수형으로 하고 폴더는 단수형으로 쓰기. 
요약 : 생성자는 없어도된다. 생성자를 import os / os chdir 로 시작경로 지절해줄수있음. wheel 파일은 알아서 경로 다 지정해준다.

예외처리는 왜 하느냐? 에러가 나도 계속 돌아가야 하는 코드면 예외처리해야됨.
예외처리는 try: ,except: 문임. try 속 코드 돌다가 오류가 나면 except 내부 코드 실행함. 어디서 유용하냐면 아까전처럼 에러나도 돌아가야하는 프로그램에서 씀. 패키지에는 워닝, 에러가 있음. 둘 다 에러로 봄. 구버전 코드를 try에 쓰다가 오류 발생하면 expcept에 신버전 코드를 돌리는거지. except 발생오류 as 발생변수(e,a,b,...): 하면 특정오류를 오류변수에 담아라. except: 는 모든 오류를, except 발생오류: 지정한발생오류 출력한다. 이거 과제에서 나왔어! 주로 print('original error :' . e) print('설명:~~'). 대체로 except: 구문만 잘 씀. 
요약하면 예외처리는 구버전,신버전 업데이트때, 계속 돌아가는 코드에서 잘 쓰인다. else: 는 지정한 오류 외의 모든 오류를 출력하라는 의미임. 이걸 자세하게 쓸수록 전문가지.  

일부러 에러를 만들어 쓰기도함. raise ErrorofError 하면 ErrorofError를 반환함. 예시로 def errors(): raise erroroferrors 하면 errors() 하면 에러문 출력함. 왜 쓸까? 예시를 들자면, 만약에 함수를 만들었다 치자. 이렇게 만들었으면 에러가 나야 정상일때 혹은 내가 만든 클래스를 남이 오버라이딩 할 때 이건 쓰지마라 라고 예외를 만들어 두는거지. 테스트용도로도 사용하기도함. 

예외도 만들어 쓸 수 있음. 클래스로 씀. class 이름(Exception): 예외를 상속받아서 씀. 매서드를 def __str__(self) return "에러발생" 이렇게 씀. raise랑 다른점은? raise는 에러라는 클래스만 올수있음(zerodivisionerror 같은 에러 클래스 구문). Exception으로 만들어서 쓰면 에러를 직접 만들어서 쓸수있음. "에러발생' = e로 감. 

1. 에러는 class다!
2. 에러만들때 exception이란 클래스를 상속한다.
3. 에러 결과함수는 __str__함수를 오버라이딩한다.
4. raise 옆에는 에러 클래스만 온다.

예시

def setname(이름):
    if 이름=="욕설"
        raise name

class name(Exception)
    def __str__(self)
        return "욕설쓰지마"

try:
    A = setname(바보)
except:
    name as e
        print(e)

결과 : 욕설쓰지마

문법이라 그냥 그런거임. 에러 발생은 언제든지 달라질 수 있어 거의 마지막에 쓰임. 파이썬 2->3 넘어갈 때 바귀었데. 
이런 예외처리는 if문의 한 종류라고 생각하면됨.

내장함수를 잘 모름. 그냥 함수가 어떤게 있다는 것만 기억해도 굉장히 유용함. 내가 생각하는 기능은 무조건 있으니 찾아봐! 
// : 몫
% : 나머지
abs(-3) = 3

이미지 .raw 파일을 후처리거친걸 JPG, PNG임
raw이미지의 pixel 값을 빠른걸로 저장해서 처리속도를 높일 수 있음. 내가 파일 읽었을 때 h5, pickle, npz 등으로 빠른 처리 방법으로 바꿔서 속도를 높일 수 있음. 아, npz파일로 저장해서 딥러닝 했더니 불러오는 속도가 느리고 pickle로 하니 속도가 빨랐어. 이것때문이구나!

내장함수(import 안해도 사용가능)
all은 잘 안씀

any는 데이터셋에서 특정 값만 추출할 때 사용함. 이미지 파일에서 특정 픽셀값을 추출할 때 처리 속도를 높혀주는 함수임.

enumerate는 열거하다란 뜻임. 리스트 번호랑 값을 나란히 출력함. 출석번호 붙이기는 딕셔너리로 간단히 할 수 있지만, enumerate로 더욱 쉽게 할 수 있음. for i idx enumerate (name) 이렇게 씀. 결고는 0 철수, 1 영희 이렇께 쌍으로 나옴. 이전에 한번 써봤지. 어려웠고!

filter는 걸러낸다는 뜻. 혼자 쓰이지 않음. 주로 lambda와 함께 씀. 이것도 반복문이랑 기능이 같아. filter(함수, 반복가능data interation) 이건 for i in 반복가능데이터: 함수(i) return 결과값 리스트. result = filter((lambda a: a+1),[1,2,3]) 이렇게 짧게 쓸 수 있음. 물론 알기 쉽지는 않음. 사람들이 잘 알아보지 못해... 그래서 선호하지 않음. 그냥 함수 정의해서 써. 잘난척 외에는 그닥?. 이러면 결과같이 참인 입력들을 반환함. 거의 안쓴데. 

lambda는 그리스어 람다임. D를 뜻한다네? 왜그러지? 함수가 데피니션 D라서 람다라고 붙임. 함수를 간단하게 쓸 수 있는 함수임. functi = lambda(a, b : a+b) 여기서 def add(a,b): a+b 이거와 같음. 정말 간단한 함수를 쓰거나 코드 줄일때 씀. 람다는 한번 쓰고 버리는 함수로 쓰임. 혹은 함수 못쓰는 곳(물론 못봤지만)에 쓰임. functi(1,2)=3 이렇게 쓰임. 똑같은 내용임. 람다는 더 빠름(미세하지만) 

id는 주소값 보는건데 잘 안씀.

int는 소수점 버림할 때도 씀.

isinstance는 굉장히 자주 씀. a,b = classA,B 선언 후 isinstance(a, class A) = True, 클래스A가 a란 인스턴스를 생성했느냐 여부를 봄. 아니면 false씀. 만약 class B 쓰면 False 뱉음. 참고로 isinstance(a, list)도 됨. 리스트도 클래스임. 데이터 거를 때 쓰기도함.

map은 filter랑 똑같은 기능(함수, 반복data를 입력으로 받음)을 하는데 filter는 결과값이 True인 것만 반환함. map은 map 자료형으로 반환함. 그래서 list형식으로 바꿔줘야됨. map 자료형은 어떤 자료형이든 변할 수 있는 자료형임. 네가 바꿔달라는대로 바꿔줘야됨. 이건 조금 씀. map lambda랑 같이 씀. 

open은 파일 여는 함수. f = open( " binary_file", "rb") 로 파일 읽을 수 있음. 물론 이렇게 파일 읽는건 메모리를 엄청 소모하기 때문에 with open(data.txt,w) 로 사용함. 그래야 자동으로 with문 끝나면 파일 닫힘. 그래야 파일 데이터가 메모리속에 계속 안담기게 할 수 있음. w는 쓰기모드로 다 지우고 새로 쓰는거임. a는 원래 내용에 추가로 씀. 

range는 시작점 끝점 몇개 띄울건지 결정하면 됨(다 숫자). rang(1,10,2) -> 1,3,5,7,9, list (range(5) =[0, 1, 2, 3, 4]

pow 는 제곱. pow(3,3) = 3^3

sorted 는 입력 데이터 정렬 함수. sorted([1,2,3]) == [1,3,4].sort() 같은거임. 리스트도 클래스이고 리스트 클래스 내부 sort 함수를 쓰는거임. 기능이 같음. 물론 sorted([1,2,3])를 더 자주 씀 리스트 말고 다른 형식에도 쓸 수 있기 때문임.

tpye도 자주씀. 이게 무슨 타입인지 알기 위해 사용함.

zip 도 자주 씀. zip([1,2,3],[4,5,6]) = [(1,4),(2,5),(3,6)]. 이렇게 묶어줌. zip 형태임... 어떤 형태로든 전환이 가능함. list(zip([1,2,3],[4,5,6])) = [(1,4),(2,5),(3,6)] 로 리스트 형태로 반환함. 입력은 같은 길이를 써야됨. 참고로 zip 반환은 for문 쓰면 하나씩 내뱉음. range도 같고. for문 안쓰면 그냥 한꺼번에 뱉지. for zip 하면 1,4 2,5 3,6 이렇게 반환함!. 이렇게 하나씩 내뱉는 이유는 메모리 최적화 때문임. 한거번에 메모리 올리면 그게 실행도 아직 안됬는데 자리를 차지하기 때문이야. 한글 넣으면 다른거 다 출력 잘하다가 한글 해석 못한다고 에러뜸. 필터랑 맵도 똑같이 반복문스면 하나씩 뱉음. 


강사님께서 이르시되, AI개발로 취업은 3년이 한계라고 생각한대. 왜냐면 매일매일 새로운 AI가 나오기 때문이래. 우리나라가 AI 강국임. 현재 AI에 천문학적인 돈을 쏟아붓는중. 우리는 AI개발보다는 AI 강사쪽이 좋을 것임. AI 거진 끝물이라 생각하기 때문이래. 요즘엔 AI 개발 속도도 점점 빨라지고 적은 인원으로 AI를 이용해 새로운 AI를 만들어내기 시작했데. 우리는 그 AI 개발 기법들의 흐름을 알아야됨. 
우리가 만든건 시장에 못팔고 기초가 되어 우리가 활용할 수 있을 것이다.

표준 라이브러리는 한번씩 보기. 그냥 그거만
time은 걸린 시간 환산할 때 씀. 시가측정 아니면 로그나 기록 남길 때 씀. 
math는 엄청 오질나게 썼지. 특수 혹은 공학적인거 계산할 때 씀
random 도 자주씀. 난수표로 만든 가짜 랜덤임. 우리가 랜덤이라 느껴서 씀. 랜덤 시드라는 것도 있음. 이 값으로 랜덤을 고정함. 일정한 값을 뽑을 때 씀. 랜덤값 고정해서 학습시킬 때 사용함.

glob도 자주씀. 요즘엔 os내부 기능을 씀. 파일 이름 출력해줌.

pikcle은 리스트로 저장하는 라이브러리. 

os는 중요하니 다 읽어보기 

쓰레딩은 쓰 지 마 버그터질수있어. 쓸려면 간단한거에 써 너무 위험해...

json은 딕셔너리로 저장하는 파일. 변수와 어떤값을 담을 때 json을 자주 씀. web형태에서 쓸 때도 json써서 좋음. 호환성 이유로 json을 씀. 이거 내가 웹 만들때 쓰면되겠다.


정규표현식이란?
처음들어봐. 우리가 쓰던 ctrl 단축키 기능들을 코드로서 표현한 식임. impor re 로 불러와서씀. 쉘스크립트에서 씀. 그나마 강사님께서 가르쳐준 저규 표현식은 * (all. 전부란 뜻) *.jpg 를 다 만족한다는 뜻. import re re.match(*.JPG) 하면JPG 다 찾음. $.JPG 하면 한글자 아무거나. rm *.jpg 다 지워버림. 나머지 표현식은 GPT에게 물어보기.  rm -rf /* 하면 있는거 하위폴더까지 강제로 삭제하라 란 뜻. 정규표현식을 파일 탐색할 때 유용하게 쓸 수 있음. 주로 입력데이터 검색해서 모을때. 
os.walk(/test) = file, dir
if file.endwith(JPG)
    file.append)
이러면 하위폴더에 있는 모든 JPG파일을 다 찾음. 

시험문제 2번
파이썬 코드에서 while문으로 무한 반복 시키는 방법도 있지만 크론탭이란 리눅스 명령어로 일정 주기마다 프로그램을 주기적으로 실행시키는 방법도 있다. 이건 몰랐네

시험문제 4번
아무래도 예외처리는 오류가 발생했을 때 프로그램이 멈추지 않고 계속 동작하도록 만들기 위해 예외처리를 함(오류나면 멈추는 사태 방지)
그리고 코드를 효율적으로 짜는 방법은 코드 형식과 좀 더 좋은 코드를 찾아서 적용하는 방법도 있지만, 코딩의 '효율적'은 시간(실행시간)과 자원(메모리)이 적은 것을 뜻한다. 실행시간을 최대한 적게할려면 코드를 간결하게적고(이해하기는 쉽게) 이중반복문 대신 리스트 컴프리헨션을 쓴다거나 딕셔너리를 쓴다거나 할 경우다. 이 방법들 중에 속도랑 메모리에 따라 빠르고 메모리 적은 방법을 무엇이든지 쓰면 된다. 
참고자료:
https://www.notion.so/planet-ms/Chap3-python-11718648fca8804ea449e4fc8c35e10b

시험문제 6번
흐름 제어는 그저 제어임. if문 쓰는거. 코드랑 대략적인 흐름만 보여주면 됨

아무튼... 정리해주신거 다시한번 읽어보자. 파이썬 잘 정리해주셨다!

묻는걸 부끄러워하지말고 적극적으로 물어보자!

헷갈리는 것
시험2번 서버에서 파이썬 스크립트 주기적으로 실행하기. 주기적이란 문장을 파악해야됨.
1. 파일을 여러번 실행시키기(스크립트 사용, 크론탭 같은것)
2. while문실행해서 루프돌리기

시험6번 효율적으로 짜기. 메모리 줄이기, 실행시간 줄이기, 코드 간결하게, 저장용량 적게, 주석 잘 적기, 효율적 코드 가져오기 등. 클론 코딩, 피어 리뷰로 스타일을 잡아가는 것이 좋음. 이런 효율적이란 생각에 곰곰히 생각해보고 의견을 표출해보는것이 좋다. 
