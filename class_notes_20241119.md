이제는 컴퓨터 구조 시모하를 배울 것임

컴퓨터 구조랑 운영체제를 배울거임. 나중에 성능 향상, 자원 효율화 확장성과 성능 극대화임. 즉 하드웨어 동작원리를 알아서 최고성능을 뽑아내기 위해 배운다. 우리가 할 프로젝트에서 메모리관리랑 병렬처리에 쓰이기 때문에 배운다.
컴퓨터의 cpu 메모리 입출력 장치에서 메모리는 램,레지스터,ssd에 하드까지 일단 저장하는 장치는 다 메모리임. 그냥 입출력 장치를IO장치라고 혹은 IO라고 부름. 

컴퓨터 구조는 두가지임. 폰 노이만 구조, 하버드구조. 폰 노이만 구조는 게임을 실행시키면 메모리가 올라감, 즉 게임 코드가 램 위에 올라가는 형식이다. 하버드 구조는 내가 짠 코드만 저장되는 공간, 데이터가 저장되는 공간이 따로 떨어져있는 구조를 말함. 대부분 폰 노이만 구조를 씀. 아니 거진 다. 왜냐하면 설계가 간단하고 범용적으로 사용 가능하기때문. 특징이 단일 메모리공간(램)에 다 저장하고 명령어랑 데이터를 동일한 버스 즉 회로선을 통해 전달하고 구조가 단순해 구현과 유지보수가 용이하기 때문이다. 그런데 메모리 병목 현상이 있다는 단점이 있어 그걸 해결할 메모리 구조가 고안됨. 하버드 구조는 램이 두 종류가 있는거지. 하나는 컴파일된 코드가, 하나는 필요한 데이터가 올라가지. 일반 범용 시스템보다는 임베디드 시스템에 들어감. 속도가 빠르기 때문(병목없음). 그리고 병렬처리에 좋음. 사실 비싸서 평소엔 안쓰지. 버스는 회로선을 의미함. 요즘엔 2개의 버스(명령어용, 데이터용)를 써서 병목을 없앰. 그게 DDR이라네??? 기본은 폰 노이만. 메인보드는 하버드 구조라네. 바이오스 칩을 쓴다네. 바이오스칩  망가지면 서비스센터 가야됨. 요즘엔 바이오스 칩 두개 써서 하나 날라가도 괜찮다. 바이오스는 데이터가, 코드는 노스 사우스 브릿지에 있어 하버드 구조임. CPU에 사우스 브릿지 넣어서 메인보드 원가 절감 시도도 있음. 그리고 노스 브릿지는 메인보드 유지보수를 위해 메인보드에 남겨둠.

CPU  동작 기본 원리를 배울거임
CPU가 처리하는 모든 명령어는 ISA에 의해 정의됨. ISA는 하드웨어와 소프트웨어간의 인터페이스를 규정함. 그러니까 논리회로를 반도체로 만들어서 그곳에 명령을 내리는 것이 ISA임. 모든 명령어가 한 과정으로 이루어지는게 아니라 명령어 한줄 읽고 실행하는데 4가지 과정으로 나뉜다고해서 파이프 라인이라고 부른다. CPU의 클록은 명령어 처리 속도를 결정함. 그러니까 클럭은 명령어 1개를 실행하는데 걸리는 시간의 기준을 정해준다. 오실레이터라고 하는 기기가 있는데, 얘가 진동해서 주파수를 발생시킴. 그 진동 1개를 클럭이라고 부름. 6GHz는 1초에 60억번 진동한다. 그런데 이 헤르츠를 무한정 높이면 좋지만 회로에는 저항이 있음. 더 빠르게 부딛히고 열이 더 많이 발생하기 때문에, 전력과 발열을 고려해서 결정한다. 이 헤르츠를 높이는 법이 오버클럭임. 요즘엔 오버클럭을 못하는 CPU가 많음. 많이 타이트하게 했기 때문임. 그래서 언더클럭이라고 전력을 줄여 클럭을 낮추는데, 전력을 줄였는데 성능이 그닥 안줄을 때가 있는데 그때가 바로 스윗스팟이라고 부름. 전력과 성능이 선형 그래프를 그리지 않기 때문. 참고로 데이터 버스, 주소 버스, 제어 버스라고 단일 버스가 아니라 하버드 구조가 적용되어 있다. 버스가 메인보드에 있던 그 금색 선을 말함.

CPU를 어떻게 제조하는지 
데이터 이동 명령어는 멀티플렉서, 줄여서 MUX라고 부르는 논리 회로를 사용함. 신호4개는 입력 2비트로 제어가능. 그러니까 신호 선택기라고 볼수있다. 반대인 DMUX도 있음. 하나의 입력을 여러개의 결과 신호길 중에서 하나로 보내는 기능을 한다. 1개 입력 신호를 입력 2비트로 4가지 결과를 낸다. 레지스터1개, 메모리10개 존재함. 2번 데이터를 레지스터에 옮길려면 MUX를 써서 선택하고, 레지스터데이터를 메모리의 3번째에 옮길려면 DMUX를 쓰면 된다. 내방 가습기 버튼 그거가 MUX랑 유사한 기능을 하지. 기능 하나만 있는 물건을 MUX로 기능을 추가하는 경우도 있다.
ALU는 반가산기랑 전가산기를 이용해 덧셈 구현 가능. 그거 알잔아 캐리 유무 그걸로 하는거지. 
CU는 비교기로 만듬.

PC, 즉 프로그램 카운터는 클럭을 셈. 1클럭이 지나면 다음 명령어를 실행함. 그거만 기억하기. 

ALU에서 ADD라고 명령을 하면 못알아먹음. 그래서 디코드, 즉 해독을 해줘야됨. ADD라는 명령어는 001을 입력해야 동작한다. 001이라고 하면 ADD 명령어가 실행되는거지. 001 0001 0003 하면 ADD 명령어로 메모리 1번지꺼랑 메모리 3번지꺼를 더하란 의미지. ADD 덧셈기 가져와서 MUX로 메모리 1번지 데이터를 레지스터에 가져오고 또 3번지 데이터를 레지스터에 가져와서 ADD회로에 데이터를 넣어 덧셈 연산을 함. 연간결과값을 레지스터 빈 공간에 저장해줬다가 연산결과값을 DMUX를 통해 레지스터의 값을 램으로 옮김.

명령어 처리 흐름도(어셈블리어로 진행됨)
5+7을 보자면 아래의 4개 명령어로 컴파일됨. 그리고 PC가 램의 주소를 0X0001부터 증가시키면서 명령을 실행함.
LOAD R1 0X0040 -> 램40번 주소에 있던 값을 R1에 올린다. 램의 0X0001번지에 저장
LOAD R2 0X0044 -> 램44번 주소에 있던 값을 R2에 올린다. 램의 0X0002 번지에 저장
ADD R3 R1 R2 -> RAM의 0X0003 번지에 저장
SOTRE 0X0050 R3 -> RAM의 0X0004번지에 저장

1. 명령어를 컴파일러로 기계어로 모두 변환해 램에 올린다. 
2. 변환된 명령어를 디코더에 적용하여 로드를 수행하는 회로에 신호를 줌. 그다음에 MUX로 램의 해당 주소에 있는 값을 레지스터1번에 옮긴다. 
3. 변환된 명령어를 디코더에 적용하여 로드를 수행하는 회로에 신호를 줌. 그다음에 MUX로 램의 해당 주소에 있는 값을 레지스터2번에 옮긴다. 
4. 변환된 명령어를 디코더에 적용하여 애드를 수행하는 회로에 신호를 줌. 그다음 가산기 회로를 이용해 연산을 개시하여 결과값낸다. 마지막으로 결과값을 레지스터3번에 옮긴다. 
5. 변환된 명령어를 디코더에 적용하여 스토어를 수행하는 회로에 신호를 줌. 그다음에 DMUX로 레지스터3번에 있는 값을 램의 해당 주소에 옮긴다.

파이프라인으로 보면
명령어 인출 : 프로그램카운터 초기화, 프로그램카운터+1(5+7명령어 위치인 램 0번 주소를 읽어냈기 때문), 읽은 명령어 레지스터에 저장
명령어 해독 : 디코더를 써서 램 0번 주소에 있던 5+7명령어를 기계어로 해독함. 5랑 7이 저장되어 있는 램 주소도 추출함. 해독해서 나온 명령어에 따라 5와 7을 MUX써서 해당 주소에서 가져와서 레지스터 R1 R2에 저장함. MUX 2번 사용
데이터 연산 : 5+7를 실제로 수행. 결과값 12를 레지스터에 저장. ALU사용
결과 저장 : 디코더를 써서 쓰기 동작 실행. 결과저장할 주소도 추출함. DMUX 써서 해당 주소에 결과값을 저장함.

### **클록 사이클별 요약**

1. **Cycle 1-2**: 명령어 인출 → PC에서 명령어를 읽어 IR에 저장.
2. **Cycle 3-4**: 명령어 해독 → 메모리에서 데이터 읽기 → R1에 값 저장.
3. **Cycle 5-6**: ALU에서 덧셈 수행 → 결과를 R3에 저장.
4. **Cycle 7-8**: 결과를 메모리에 쓰기 → 값 12가 주소 `0x0050`에 저장.

5+7 명렁어가 아래의 4개의 명렁어로 컴파일됨 그리고 PC가 ram의 주소를 0x0001부터 증가시키면서 명렁을 실행함. ⇒폰 노이만 구조라서 ram에 데이터랑 코드가 둘다 올라감. load나 add 나 store는 opcode에 의해 숫자로 변경됨 그리고 decoder에 들어가서 회로를 선택함.

load r1 0x0040 ⇒ ram의 0x0001번지에 저장
load r2 0x0044 ⇒ram의 0x0002번지에 저장
add r3 r1 r2⇒ ram의 0x0003번지에 저장
store 0x0045 r3⇒ ram의 0x0004번지에 저장

어쨌든 램에 저장해둠 빈공간에. 로드 애드 스토어 모두 컴파일러에 의해 변환되 디코에더 들어가 회로를 선택함.

인터럽트는 잠깐 프로그램 멈추게 하는 걸 듯함. 그예로 키보드. 키보드에 컨트롤칩이 있어 스게 데이터를 전달해줌.
키보드 쳤을때 실시간으로 왜 되느냐? 프로그램 중단하고, 키보드 입력 처리하고 다시 중단된 프로그램 실행됨. 프로그램 카운터를 제어할 수 있는 것이 인터럽트임. 프로그램 카운터 정보를 따로 저장해뒀다가 다시 불러와서 진행함. 인터럽트는 프로그램카운터를 올리지 않음. 인터럽트는 하드웨어적인 방식으로 인터럽트 신호 처리하는 칩이 있음. 풀링은 소프트웨어적인 방식. 실시간 감시임. 이러면 연산을 많이 잡아먹어서 안좋음. 인터럽트중에 인터럽트하면 인터럽트의 주소를 가져오게됨. 아이고; 이게 쌓이면 인터럽트 폭동이라고함. 리모콘도 인터럽트씀.

DMA는 몰라도되 그냥 적어둔거...

풀링은 CPU가 계속 키보드 감시하는 방식임. CPU자원 잡아먹는다는 단점이 있음. 이거쓸바엔 인터럽트쓴다. 그래도 쓰는데 있어. 하드웨어 더 안달아도되니까. 그리고 주기적으로 입력을 확인하는데, 그러니까 통신작업에 유용함. 이메일에 쓰임. 마우스에도 풀링씀. 마우스에 인터럽트 쓰면 자원소모가 훨씬 더 심하기 때문에 풀링을 쓴다.

CPU동작원리 어셈블리어
풀링 어셈블리어 복습하기. 러프하게 설명해서 노션 읽어봐야됨. 정리도 하고.


Q. 컴퓨터 구조 왜 배우냐
A. 컴퓨터를 최대성능으로 쓰기 위해서. 프로젝트에서는 메모리관리, 병렬처리에 쓸려고 배움. 딥러닝에 필요하지 암.
Q. 컴퓨터 구조하는데 뭘 알아야해?
A. CPU, 메모리, I/O 의 역할과 상호작용
Q. 컴퓨터 구조에서 폰 노이만 구조랑 하버드 구조의 차이점은?
A. 폰 노이만은 코드랑 데이터를 같이 저장, 하버드는 따로 저장. 폰 노이만은 버스 같은거 써서 병렬 현상 일어나는데, 버스 수를 늘려서 해결함. 그러니까 폰 노이만+하버드 혼합해서 쓰는 방식이 대세임.
Q. ISA는 뭐냐
A. 그냥 하드웨어 다루게 해주는 명령어라고 보기. CPU 명령어 모음이라고 보면 된다. CPU 설계따라 ISA 만들지. 하드웨어와 소프트웨어 간의인터페이스를 규정한다고함.
Q. MUX, DMUX는 뭐냐?
A. 데이터 이동 명령어 쓰면 등작하는 회로다. 램에서 특정 주소로 접근해서 값을 뽑아오거나(MUX) 저장할 때(DMUX) 사용한다. 데이터만 뽑아오는거다?
Q. CPU의 ALU에서는 무슨 회로를 쓰냐?
A. 가산기요. 이걸로 다 처리가능하다네? 아무튼. NOT OR AND 같은 논리회로도 쓰여.
Q. 그럼 CPU의 CU에서는 무슨 회로를 써?
A. 비교기랑 프로그램 카운터. 그냥 비교기 쓴다고만 이해하자. 프로그램카운터랑
Q. 디코더는 뭐냐?
A. 그냥 명령어 해독해서 명령어를 선택해주는 선택기로 보자. N번 코드 실행되면 ADD 명령어 실행되는거지.
Q. 그럼 실제 명령어는 어떻게 처리되냐?
A. 명령어 인출( 프로그램 카운터로 명령어 컴파일된 코드를 램에서 레지스터로 가져옴) - 명령어 해독(처리할 데이터를 MUX써서 램에서 레지스터로 가져옴) - 데이터 연산(두 레지스터에 있는 데이터로 ALU에서 연산해서 레지스터에 저장함) - 결과 저장(DMUX써서 레지스터에 있는 연산 결과값을 램에 저장함)  
Q. 인터럽트는 대체 어디다 쓰는거냐?
A. 키보드나 리모콘에 써. 실행중인 프로그램 잠시 중단하고 인터럽트부터 우선 처리한다음 중단된 프로그램을 진행시키지. 인터럽트랑 프로그램 주소를 따로 저장해둬서 이런 동작이 가능해
Q. 노스브릿지랑 사우스브릿지 위치는?
A. 몰라! 그거 기기마다 달라서 메인보드 뜯어봐야해
Q. DMA는 설명 안해주던데 그게 뭐냐?
A. 인터럽트 비슷한건데 입출력 장치 데이터가 CPU를 거지지 않고 교환되는거임. DMA는 인터럽트랑 폴링이랑은 좀 다름. 요약 :  인터럽트는 소규모 이벤트 중심의 신속한 반응을 제공하며, DMA는 대용량 데이터를 빠르고 효율적으로 전송할 수 있습니다.
Q. 메모리 계층 구조를 왜 만들어진거야?
A. 최적화를 위해서배워. 그러니까, 전부 레지스터 쓰면 빠른데 비용이 엄청 커져. 결국 비용문제지. 레지스터로 갈수록 속도는 빠르고 용량은 작고 가격은 비싸져. 그러니까, 속도와 용량의 균형, 비용 절감을 위해서겠네.
Q. 캐시 히트, 캐시 미스? 이건 또 뭐야?
A. CPU가 메모리에서 데이터를 찾는데, 없으면 미스, 있으면 히트야. 캐시 미스가 뜨면 하위 메모리에 가서 데이터를 찾아와야되서 처리속도가 느려질수있어. 이 캐시 미스를 빠르게 처리하기위해 메모리의 시간적, 공간적 지역성을 이용하지.

메모리 배울거임. 메모리에 모두 다 담으면 비용문제가 있어 계층구조로 나눔. 레지스터 캐시메모리 주기억장치 보조기억장치 전부 메모리임. 각 계층마다 가격과 속도 용량이 판이하게 다름. 레지스터로 갈수록 용량이 줄어드는데 무슨 문제가 발생할까? 보조 장치에 있는 데이터를 주기억 장치에 모두 담을 수 없다. 그렇기에 일부만 담을 수 있음. 그 일부를 담는 알고리즘이라고 해야하나 효율적으로 퍼담는 방법이 있음. 그게 시간적, 공간적 지역성임. 1초 뒤에 잡히는 곳엔 거의 항상 고래가 잡히고 고래가 잡혔던 곳은 고래가 잘 잡힐 것이다. 그거임. 그래서 이거 때문에 캐시 미스 캐시 히트라고 함. 데이터를 아래에서 위로 가져왔을 때 원하는 데이터가 있냐 없냐를 말함. 변수 선언 한곳에 하면 데이터가 서로 비슷한 곳에 저장되서 데이터 관리가 편함. 파이썬은 데이터 관리 잘해주는데 그냥 느린거임. 게임할 때 프레임 올리기 위해선 이런 데이터 관리가 중요함. 데이터 관리 잘된 게임은 이런 프레임 유지가 잘됨. 성능 좋게 할려면 램이나 GPU램에 게임 까는 방법도 있음. 물론 비싸지만. 이래서 다다익램... 캐시 교체 알고리즘은 캐시가 다 찼을 때 사용하는 방식으로, 기존 데이터를 새 데이터를 교체하는 방식임. 가장 적게, 오랫동안 사용된 데이터를 제거해 캐시 메모리 용량을 확보하여 새 데이터를 캐시에 올리는거지. 커널이 데이터 용량을 제어함. 그러니까 운영체제가 자원확보하는거지. 랜덤 방식이나 가장 먼저 들어온 데이터를 없애는 방식도 있음.
가상 메모리는 스왑 메모리임. 주기억장치가 32기가만큼이고 가상 메모리를 64기가로 설정하면 주기억장치에서 64기가만큼의 주소를 가져옴. 이론상 무한 메모리인데 SSD에서 해당하는만큼 메모리를 떼와다가 쓰는 방식이 가상 메모리다. 캐시 미스를 했을 때 퍼오는거는 LRU가 동작함. 가상 메모리는 캐시 미스를 햇을 때 가상 메모리가서 가져오기만 하면 된다. 캐시 미스를 했을 때 데이터를 퍼오는 알고리즘은 안써서 속도가 빨라짐. 작업관리자-메모리 부분에 커밋됨을 보면 가상 메모리를 얼만큼 할당됬는지 볼수있음. 램은 게임할 때 적당한 용량(딱맞는 용량 써야 코어가 하나 처리할 수 있는 용량을 써야됨 안그럼 처리속도가 느려짐)과 램 갯수 2개(버스늘려서 병목현상 방지)면 좋다. 이렇게 작업용이든 게이밍용이든 딥러닝 용이든 용도에 맞게 메모리같은 부품을 쓰는거지. 

CPU 성능 향상법
파이프라이닝이 있음. 명령어 인출 해독 데이터 연산 결과저장 이거임. 
분기 예측도 있음. 내가 IF라고 했을 때 그 조건이 맞을지 틀릴지 모른다. 이전에 맞았으면 맞을거다라고 취급하는거지. 그래서 미리 계산을 해두는 거지. 그래서 FOR문이나 IF문 많이 쓰면 프로그램 카운터가 끊겨서 버벅댈수있음. 미리 계산해두고 틀리면 날려버지는거지. 어셈블리어로 짜면 이런 낭비가 없어. IF 나 FOR문 없기 때문. IF문 GOTO를 엄청쓰지. 파이썬도 FOR문 너무 많이쓰지마 속도저하 일어난다. 미리계산다 해두느라 속도 느려져 이게뭐야. 분기예측도 코드를 얼마나 잘 짜느냐에 따라 프로그램 성능을 높일 수 있음. 

슈퍼스칼라는 멀티코어이면 여러개명령어 동시에 처리가능하다. 멀티스레드는 명령어를 적당히 쪼개서 각각 처리하는거. 슈퍼스칼라에 씀. 그래서 프로그램 여러개 실행할 수 있는거지. 엄청난 속도로 프로그램을 번갈아가며 실행해 동시에 쓰는것처럼 보이게함. 

중요함.
멀티코어 멀티스레드 분기예측 파이프라인 이 4가지가 CPU 성능향상법임. 빠르게! 하드웨어적 소프트웨어적인 방법 둘다임. 트랜지스터 잘 만들면 그게 하드웨어적인 성능향상법. 소프트웨어랑 하드웨어를 둘 다 잘 다뤄야 성능이 향상됨. 하드웨어를 잘 알고 소프트웨어를 만들어야 성능을 최대한으로 낼 수 있음. 

파이썬은 멀티코어 자동지원. 멀티스레드는 나중에 최적화할때 쓰기. 안그럼 위험해.

참고로 아무런 문제도 안일어나면 누군가가 열심히 일하고 있다는 방증임. 

처음부터 멀티코어로 안짬. 안그럼 버그터짐. 위험도 높은 기술이 멀티코어임

메모리계층구조까지는 꼭 알아야됨. 그 뒤는 그냥 흐름만 보면