왜 수학을 배우는가? 머신 러닝에는 선형회귀가 있음. 이건 어떠한 값으로 수렴한다는 것을 의미함. 머신러닝이란 컴퓨터가 학습을 하는 학습론임. 짚고 넘어가야하는건, 컴퓨터과학(computer science)가 무순 학문인지 알아야함. 머신러닝의 근본인 컴퓨터과학을 악아야하지. 알고리즘&정보...등 컴퓨터과학이란 컴퓨터공학에선 어떤걸 배우는가? 컴퓨터는 계산기임. 숫자를 입력하면 어떠한 결과가 나옴. 숫자는 정보를 말함. 컴퓨터과학을 정의하자면, 어떠한 정보에 대해 컴퓨터가 처리하는 방식을 이해하는 학문. 처리방식을 알고리즘이라고 함. 알고리즘은 어떻게 작성될까? 알고리즘은 프로그래밍 언어로 작성됨. 그러므로 컴퓨터 하드웨어(구조, 역할), 소프트웨어(OS, DB...)를 배움. 머신러닝은 알고리즘 중에 하나임. 면접상에서도 이런 질문들 위주로 나옴. 알고리즘을 배우면 심화단계가 시작된것임. HW,SW 는 기초단계임. 기초는 필히 알아야됨. 그게 면접문제임. 머신러닝은 심화문제라 알고리즘, 즉 프로그래밍 언어로 딥러닝 할 수 있는지 물어봄. 머신러닝은 알고리즘을 이해하고 작성을 할 줄 알아야됨. 옛날엔 그런 능력이 높게 요구됨. 요즘엔 강력한 AI가 등장해 요구능력이 낮아짐. 작성은 문제가 아니라 이젠 이해가 철저해야됨. 알고리즘의 이해가 철저해야 살아남을 수 있음. AI는 도구일 뿐! 기초와 알고리즘에 대한 이해가 더욱 중요해짐. 그래서 수학(기초학문)을 배움. 그래야 알고리즘을 이해할 수 있지. 옛날엔 코딩테스트 위주였는데, 알고리즘을 어떻게 짜느냐가 요즘엔 중요해짐. 공부방식을 바꿔야 될 것임. 파이썬 문법, 공부가 아니라 알고리즘이 어떻게 돌아가는지를 이해하고 어떻게 쓰는지을 이해해야하는게 중요함. 이해가 중요함! AI가 작성한 코드를 이해할 줄 알아햐함.

머신러닝이란 무엇일까(how)? 일단 딥러닝은 정보를 신경망을 이용해 예측하는 것. 머신러닝은 정보를 신경망을 이용하거나 이용 안하고 예측하는 것. 정보예측하는 것이 머신러닝. 무언가를 예측하는 학문이 머신러닝과 딥러닝임. 궁극적인 목적은 정보예측. 무엇을 어떻게 예측하는지를 배울 것임. 예시로 일기예보가 있음. 대체로 예측이란 말만 들어가면 머신러닝임. 참고로 강화학습을 머신러닝이 아님. 정보를 받아 어떤 행동을 할 지(rule pase. 예시로 if문) 결정함. 이거 보드게임 가상의 적 행동 종이가 예시임. 머신러밍 안에 딥러닝이 있고 강화학습은 머신러닝, 딥러닝에 겹치거나 안겹치거나 그럼. 강화학습에서 신경망으로 어떠한 행동으로 예측하고 예측중 하나를 결정함. 강화학습이 딥러닝에 속한다는 것은 아님. 강화학습 중에 일부가 딥러닝에 속할 뿐임. 강화학습 중 알고리즘으로 딥러닝, 머신러닝, 룰베이스를 쓸 뿐임. 가장 중요한 것은 정보를 무엇을 어떻게 예측하는 것임. 수학에선 예측을 위해 함수가 필요함. 머신러닝은 함수의 학문임. 어떤값 주어지면 값을 뱉기 때문임. 그래서 함수가 기본임. 어떻게 예측할까?=어떻게 흐름을 볼까? 흐름엔 단계가 있음. 1입력(실제 데이터를 알고리즘에 맞게 변환해줘야됨. 주로 행렬과 벡터로 변환해줘야됨. 왜 변환해줘야되는가? 실제 데이터는 아날로그고 알고리즘에 맞게 변환된 데이터는 디지털 데이터임. 아날로그는 대용량 데이터임. 아날로그를 디지털로 변환했을 때 효율적인 표현 방식이 행렬과 벡터일 뿐임. 사실 디지털 데이터는 벡터 기반으로 되어있기 때문임. 그리고 효율적인 처리를 위해 선형 대수를 배움. 실제 데이터는 디지털 기반인 컴퓨터에선 못쓰니까 가장 효율적인 행렬과 벡터로 변환해주는 거임). 2함수(전처리된 데이터...그러니까 아날로그에서 디지털 방식으로 변환된 데이터로 함수를 결정함. 함수를 결정한다는 말은 여러가지 함수들 중에 내 데이터에 가장 잘 맞는 함수를 선택한다는 말임. 1차, 2차 함수 형식으로 나오면 그 형식 쓰면 된다. 가장 잘 맞는 함수는 어떻게 고를까? 내가 정한 기준의 오차가 적은 함수를 바탕으로 함수를 고른다. 그 방식이 대표적으로 역전파와 손실함수이고, 이 둘은 편미분을 이용하고 그래프도 이용한다. 오차를 이용해 함수를 고른다) 3예측 데이터를 넣어 예측한다. 딥러닝에선 여러가지 함수들이 신경망 함수 중에서 결정됨. 즉, 딥러닝은 신경망 함수(퍼셉트론, CNN, 트랜스포머)만 씀. 딥러닝과 신경망은 사용된 함수가 신경망 함수인지 아닌지로 나뉨. 추상적 설명보단 정확한 설명을 요구함. 

행렬과 벡터는 데이터의 특징을 담을 수 있기에 컴퓨터 정보 기반으로 사용됨. 

머신러닝 단계

1. 입력 : 실제 데이터를 알고리즘에 맞게 변환(데이터 전처리) -> 아날로그 데이터를 디지털 데이터(행렬과 벡터. 효율적인 표현방식임)로 변환
2. 함수 : 전처리된 데이터로 함수를 결정 -> 여러가지 함수들 중 내 데이터에 가장 잘 맞는 함수(내가 정한 기준의 오차가 적은 함수를 바탕으로 함수를 선택하는 흐름을 반복함. 오차는 손실함수를 이용해 구함. 이때 역전파도 사용되고 편미분을 이용함)를 선택. 
3. 예측 : 데이터를 넣어 예측. 예측 안맞으면 1~3 반복

수학
1. 함수에 대한 기본 정의, 그래프(형태 및 표현방법)를 익힘
2. 벡터와 스칼라의 기본 정의와 구성을 배움
3. 미분의 기본정의와 종류, 구성을 배움
4. 벡터와 스칼라, 함수의 조합
    함수는 입력이 1개이고 출력이 1개인 일변수 함수, 입력이 n개이고 출력이 1개인 다변수 함수 둘 다 스칼라 함수, 벡터함수로 나뉘어서 4가지 종류의 함수가 존재함. 아래 4가지 특징을 공부함. 이들 중 다변수 벡터 함수를 머신러닝에 사용함. 합성함수, 역함수도 배움
        1. 일변수 스칼라 함수
        2. 다변수 스칼라 함수
        3. 일변수 벡터 함수
        4. 다변수 벡터 함수
5. 미분과 함수의 조합을 배움. 
    일변수 함수 -> 도함수
    다변수 함수 -> 편도함수
    체인룰을 배움

6. 행렬=선형대수학의 정의, 종류, 방정식으로 변환, 풀이법을 배움(다변수 벡터 함수를 풀기 위함) 끝!


1. 함수는 표현하는데 씀. 내가 원하는 기능(function)을 식으로 표현하는데 씀. 오차함수같은 것. 
2. 벡터와 스칼라는 데이터 표현에 씀
3. 미분
4. 다변수 벡터 함수는 함수의 종류(신경망 함수를 표현)
5. 미분과 함수의 조합은 손실함수 표현과 오차값이 최소가 되는 지점(그순간의 변화량)을 찾는데 씀
    미분과 함수의 조합도 개념만 익혀도됨. 왜냐하면 컴퓨터가 자동으로 미분을 해주기 때문임. 파이토치나 텐서플로우를 쓰기 때문임.
6. 행렬=선형대수학은 그 최소 지점으로 가중치를 효율적으로 계산(방정식 풀기)하여 갱신할 때 씀.
    선형대수학은 개념만 익혀도됨. 왜냐하면 컴퓨터를 통한 자동연산이기 때문임. numpy쓰기 때문임.

1~4는 정의이자 개념임. 사용법도 익혀야됨. 외우자! 그래야 5,6을 이해할 수 있음. 
이것들이 우리가 왜! *수학을 배우는 이유*임. 이것들을 알아야 알고리즘을 설계할 때 문제가 없음

100점짜리 말! 
머신러닝을 수학적으로 표현하자면, 데이터의 특징을 벡터로 변환한 것을/ 다른 벡터로 맵핑하는 식을/ 미분을 통해 함수에 잘 맞는 가중치 값들을 결정하는 알고리즘.
전처리, 신경망 함수, 역전파가 들어감. 맵핑하는 식=함수. 책 한번 읽어보면 됨. 넘파이 선형대수책, 기초수학 파이썬책. 최대한 이해만 하면 됨. 
실무에 사용되는 배경지식은 사실 이게 다임. 다른건 데이터 종류에 따라 달라짐. 실무에선 함수를 바꿔서 사용함. 손실함수 바꿔쓰기 같은거. 인터넷에 검색하면 됨.  

안보고 정리하거나 상세하게 살을 덧붙여보기

================================================


머신러닝 단계
1. 입력
    우리 일상에 쓰이는 모든 정보는 아날로그 데이터인데, 아날로그 데이터는 용량이 너무 크고 연속적이라 행렬과 벡터로 표현되는 디지털 기반인 컴퓨터에서는 쓸 수가 없음. 그렇기 때문에 데이터 전처리를 통해 아날로그 데이터를 디지털 데이터로 변환을 해줘야 머신러닝에 쓸 수 있음.
2. 함수
    전처리된 데이터(디지털 데이터)를 함수의 입력으로 삼아 함수를 결정함. 함수를 결정하는 방법은 함수의 결과를 손실함수의 입력으로 하여 계산된 오차값을 통해 손실함수의 미분값을 구하고, 이 미분값으로 함수의 가중치를 갱신하는 방법이다. 이 함수가 신경망을 쓰는지 안쓰는지에 따라 딥러닝 유무가 갈린다.
3. 예측
    완성된 함수(학습완료된 함수)에 입력을 넣어 정답과 비교해 예측을 실시한다. 만약 예측이 자신이 기대한 실제 성능보다 부족하다면 2. 함수 를 다른 방법으로 결정해야 할 것이다. 혹은 1. 입력의 데이터 전처리 방식을 바꾸던가.

수학을 왜 배워야 하나?
*알고리즘(컴퓨터가 정보를 처리하는 방식)을 설계할 때 수학이 사용되기 때문임.*
이 알고리즘을 손으로 설계할지, 신경망 함수를 사용하여 만들지, 아니면 다른거 쓸지는 자유임. 알고리즘은 머신러닝, 딥러닝은 알고리즘의 한 종류일 뿐. 우리가 머신러닝을 할 때 필요한 수학에는 함수, 미분, 스칼라와 벡터, 선형대수학(행렬)이 있음.

우리가 배울 수학의 흐름
1. 함수
    함수는 입력을 받으면 결과를 출력하는 수학 식임. 대표적으로 f(x) 로 표현함. 함수는 입력을 받으면 반드시 출력이 하나여야함. 입력에 사용되는 변수에 따라 함수를 구분함. 다항함수(덧셈으로 이어진 숫자의 갯수n에 따라 n항 함수라 부름), 다차함수(식에 쓰인 변수들 중에 가장 높은 차수n에 따라 n차 함수라 부름), 일변수함수(식에 변수가 한 종류만 있음), 다변수함수(식에 변수가 두 종류 이상이 있음) 가 있음. 또한 입력이 스칼라, 벡터인지에 따라 스칼라 함수, 벡터 함수가 있음.
2. 스칼라와 벡터
    스칼라는 크기를 표현하고 벡터는 크기와 방향을 둘 다 표현한다. 대체로 스칼라를 먼저 배우고 벡터를 배운다. 벡터는 함수 기호 위에 화살표를 추가해 표현하며 행렬로 표현된다. 벡터는 분해 가능하며 분해된 벡터를 요소라고 한다. 크기가 1인 벡터를 단위벡터라고 한다.
3. 미분
    미분은 변화율을 나타낸다. 두 간격 사이의 값이 얼만큼 변하느냐에 따라 값이 달라지며 두 점 사이의 간격이 크냐, 아니면 0에 가까울 정도로 작냐에 따라 평균변화율, 순간변화율이라고 한다. 대체로 잘게 쪼개어 계산한다. 컴퓨터는 0에 가까워지는 극한의 개념을 사용하기 어려워 중간 차등과 같이 근사를 통해 순간변화율을 계산한다. 미분값이 양수이면 값이 증가하고 있다는 뜻이고, 미분값이 음수이면 값이 감소하고 있다는 뜻이다.
4. 스칼라&벡터와 함수의 관계
    일변수 스칼라 함수 -> f(x) = y. 함수가 선으로 표현됨
    다변수 스칼라 함수 -> f(x,y,z) = k 같은거. 이 경우엔 함수가 덩어리로 표현됨.
    일변수 벡터 함수 -> 벡터 변수가 한 종류일 때를 말함. 
    다변수 벡터 함수 -> 벡터 변수가 둘 이상의 종류일 때를 말함.
    스칼라 함수는 변수 종류에 따라 그래프 차원과 함수의 모양이 결정됨
    벡터 함수는 벡터 변수에 사용된 요소 갯수에 따라 그래프 차원이 결정되고 벡터 변수 종류에 따라 함수의 모양이 결정됨.
    머신러닝의 함수는 다변수 벡터 함수가 사용됨
5. 미분과 함수의 관계
    일변수 - 도함수
    다변수 - 편도함수
    합성함수면 체인룰을 통해 미분을 실시
    각종 함수 공식이 있음. 
    머신러닝의 학습 중에 역전파 기법에 사용되어 가중치w를 구하는데 핵심적인 역할을 함.
6. 행렬(선형대수학)
    벡터는 전처리된 데이터 입력과 다변수 벡터 함수의 효율적인 계산을 위해 사용됨. 

# 최신 우분투 24.04 베이스 이미지 사용. hub.docker. 에 우분투 검색해서 오피컬-태그에서 버전 자기가 만들고 싶은걸로 쓰기
FROM ubuntu:24.04

# 파이토치 한국 사용자 모임에서 알맞은 파이토치 버전을 맞게 보기. 여기선 12.4 버전 필요
# pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124

# 우분투 허브에서 cuda 검색- 엔디비아/쿠다 클릭 파이토치에 맞는 쿠다 버전 가져오기
# 이미지에서 레이어 cuda만 뽑아낸다. AS로 cuda로 명명함.
# 파이토치에 리눅스 그중에 우분투 버전을 명시 안해줬기 때문에 우분투 버전 아무거나 쓰면됨. 12.4.1 대신 22.04 버전 있으면 좋은데 안줘도 상관없긴해
FROM nvidia/cuda:12.4.1-base-ubuntu22.04 AS cuda
# nvidia/cuda:12.4.1-base-ubuntu22.04
# nvidia/cuda:12.4.1-cudnn-devel-ubuntu22.04    베이스랑 개발자버전은 용량 차이가 엄청남. 

# 비대화형 모드로 설정. 가끔 강제적으로 사용자 입력을 받는 명령어가 있어서 -y를 붙여줘야 되는 경우가 있음.
# 또, GUI로 설치하는 화면이 나오는 경우도 GUI 안쓰도록 설정을 하는 명령어를 명시해줘야됨.
ARG DEBIAN_FRONTEND=noninteractive

# 작업 디렉토리 설정
WORKDIR /workspace


# 레이어 안늘어나게 둘을 묶어서 레이어 합침
# 도커는 실시간으로 입력을 줄 수 없음. 그래서 Y쳐서 업뎃해야하는 경우는 에러가 떠버림. 넌인터렉티브 모드로 해당 명령어를 바꿔줘야됨.
# apt upgrade -y 업그레이드는 웬만하면 쓰지말기. 업그레이드 하면서 레이어 호환성이 깨져버릴 수 있음.
RUN apt update && apt install -y \
python3 python3-pip python3-dev \
build-essential curl git wget

RUN pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu124

# 총 레이어는 7개(6+1. 1은 AS CUDA라서 추가됨. 대문자로 친 명령어 한개당 한 레이어 생성)
# 본인만의 환경만들기 - but 가볍게 만들어보기. 
# 
# docker run --gpus all -it -v /home/kgj0096/code/pytorch_env:/workspace test1


# 명령어 순서가 바뀌었습니다.
# 컨테이너 생성 명렁어 : docker run --gpus all -it <컨테이너이름:tag> -v <로컬폴더>:<원격폴더>
# 에서
# 컨테이너 생성 명렁어 : docker run --gpus all -it -v <로컬폴더>:<원격폴더> <컨테이너이름:tag>
# 로 바꿔야합니다. 그렇지 않으면 오류가 납니다.
# docker: Error response from daemon: failed to create task for container: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: "-v": executable file not found in $PATH: unknown


# # 최신 Ubuntu 24.04 베이스 이미지 사용
# FROM ubuntu:24.04

# #이미지에서 cuda만 뽑아낸다.
# FROM nvidia/cuda:12.4.1-cudnn-devel-ubuntu22.04 AS cuda
# # 비대화형 모드로 설정
# ARG DEBIAN_FRONTEND=noninteractive
# #작업디렉토리 설정
# WORKDIR /workspace

# RUN apt update && apt install -y \
# python3 python3-pip python3-dev \
# build-essential curl git wget

# RUN pip install torch torchvision torchaudio —index-url https://download.pytorch.org/whl/cu124

# 빌드 명령어 : docker build -t <이름:tag> .
# 컨테이너 생성 명렁어 : docker run --gpus all -it <컨테이너이름:tag> -v <로컬폴더>:<원격폴더>
# 컨테이너 시작 명렁어 : docker start <컨테이너 이름>
# 컨테이너 접근 명렁어 docker attach <컨테이너 이름>
# 컨테이너 접근 1회 명렁어 : docker exec <컨테이너 이름> <명렁어>
# **계속 접근 : docker exec -it <컨테이너 이름> /bin/bash