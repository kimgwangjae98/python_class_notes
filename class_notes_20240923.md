CPU RAM MB SSD;HDD power GPU : 컴퓨터 구성요소
CPU : 연산만 하는 부품. 연산은 더하기 빼기 나누기 곱하기 이동하기 등 명령어들을 처리함. 모든 명령어는 스위치로 구성할 수 있음. 명령어는 스위치들의 집합이란 말이다. CPU는 반도체로 이루어진 스위치들로 이루어짐. INSTRUSTIONS SET ARCHETECH(ISA). 는 명령어들의집합. CPU 생산기업, CPU 설계기업이 나뉨. 섭계기업의 설계도를 생산기업에서 생산함. ISA는 회사마다 다름. 다운받을 때 x32,64BIT는 명령어 크기임. 명령어 복잡 = 명령어 크기 큼. 이걸 왜 배우냐면 임베디드 시스템은 독자적인 CPU를 가짐. 윈도우에서 짠 ISA가 먹히지 않을 수 있음. 이런 사태를 방지하고 이걸 명령어 버전이라던가 그런걸로 설명할 수 있는 능력을 기르기 위함임. RISC, CISC 는 차이가 있음. RISC는 소비전력 적고 발열도 적음(명령어셋이 적어 CPU크기도 작음). 임베디드나 핸드폰에 적합함. CISE는 컴퓨터 같은데에 적합함. 레지스트도 있는데 이건 나중에 설명할거임. 
SSD는 0과 1로 저장함. 우리가 쓴 코드를 0과 1로 바꿔주는 컴파일러가 사용됨(번역기). 컴파일러를 거친 데이터(0,1)를 SSD에 저장함. HDD는 모터 돌아가면서 0과 1을 디스크에 새김(소리남). SSD는 전자식으로 저장해서 발열이 있음
RAM(radom accecs memoy). 이건 왜 쓰냐면 CPU-SSD간에 처리속도차가 너무 나서 이 중간에 다리같은 역할을 해줌(SSD보다는 처리속도가 빠름). CPU안에 캐시메모리도 있음.(CPU-RAM 속도차 보충). RAM은 국자와 같고 SSD는 우물과 같음. RAM이 크면 이런 국자가 크다는 거고 SSD에서 데이터를 한번에 많이 담아서 쓸 수 있다는 거임. 이러면 처리속도가 빨라지는거지. 프로그램을 실행할 때 관련된 데이터도 같이 RAM에 올리지. 그래서 RAM이 크면 좋다. 
MB는 메인보드OR마더보드라고 부름. 사실 컴퓨터에서 가장 중요한 부품임. 차의 프레임 역할과 같기 때문. 각 부품을 연결해주고 부품에 전력분배를 해주고 부팅관리도 해줌(바이오스, 펌웨어). 그 연결선이 BUS임. BUS는 소프트웨어적인 개념임. pice(LANE)는 해드웨어적인 개념임. LANE 갯수가 많으면 병렬 처리가 수월함. 그래서 메인보드가 중요해짐. 바이오스는 메인보드에 부착된 부품의 데이터를 저장해주는 부품임. 펌웨어는 시작 순서가 기록된 것(부품 부팅순서, 부팅방법 기록). 바이오스가 뭔가에 대한 답을 명쾌하게 할 줄 알아야해!
게임을 할 때는 램은 많을수록 좋다는데 그 이유는 뭔가
부팅순서 - 메인보드에 전원버튼 누르면 그게 파워에도 신호가 가서 전력이 생기는데, 이 전력을 메인보드의 펌웨가 부품 정보를 이용해 다른 부품에 전력을 분배함. 그리고 부팅순서를 가져오지. 그리고 부팅정보가 있는 기억 장치를 읽음(SSD, HDD). efi가 부팅영역임. 여기에 부팅 데이터가 있음. efi는 0과 1을 저장하는 파일 형식임(.epi같은거). efi는 500mb정도 있으면 됨. 이 안에 부팅에 필요한 데이터(드라이버)가 들어가있음. 드라이버는 하드웨어를 제어하는데 사용되는 소프트웨어. 부품 드라이버들이 쭉 로드되고 시스템 영역에서 커널이나 쉘들을 읽어내어 윈도우가 부팅됨. 커널 쉘은 신경쓰지말고. 윈도우에 사용되는 프로그램들이 불러와져 os가 부팅됨. 커널은 드라이버들의 집합체임. 커널에서 드라이버가 동작함. 인터페이스(GUI)에서 내려진 명령을 커널에서 처리함. 이런 커널들과 인터페이스들을 나누기 위해 쉘이라고 함. efi엔 드라이버들의 주소가 담겨있음. 드라이버가 efi에 있는건 아님. efi가 반드시 먼저 실행됨. 안그럼 윈도우 실행안됨(순서를 윈도우가 efi를 가장 먼저 실행하라고 하기 때문). efi가 2개일수도 있음(듀얼 드라이버). 이런건 기본 지식이니 암기하자. 바이어스에 efi의 주소가 적혀있음. 질문 : EFI 를 분할해서 다른 저장장치에 각각 넣고 부팅순서만 잘 맞추면 윈도우 부팅이 가능한가?
이제 프로그램을 어떻게 다루는지, 사용방법을 익힘. 프로그램이란 프로그램 언어로 만들어진 파일+데이터들의 집합. 프로그램도 결국 프로그램 언어로 작성하고 컴퓨터가 알아듣도록 컴파일(번역)된 파일에다 필요한 데이터들의 집합. 어려운 개념은 아님. 파일 확장자는 이 파일이 어떤 형식으로 이뤄졌는지 알려줌. 확장자는 없어도됨. 알려주기만 하면됨. 그 예시가 쉘 스크립트. EXE는 설치파일임. EXE에는 설치코드+컴파일러+데이터 가 있음. 컴파일러가 있어야 설치코드를 알아먹음. 없어도 되는데 있어야 좋다. 설치중... 나오면 컴파일러 실행되고있는거. 컴파일된 파일들이 BIN에 있음. 바로가기는 BIN파일 위치를 알려줌. X64, X32같은 형식이 있는 이유는 컴파일러가 다른 경우 혹은 설치 환경이 다른 경우가 있음. X64, X32는 미리 컴파일된 BIN 파일이 함유되어있음. 그냥 실행하기만 하면 됨 컴파일을 미리 해둬서 컴파일러가 없어오됨. EXE도 압축 데이터, 코드, 컴파일러가 들어가있음. EXE, BAT 파일은 쉘 스크립트(CMD)도 짠거지. 이런 설치같은건 쉘영역 에서 동작함. 컴파일러는 시스템 명령임. 완전히 01로 완전히 변환하지 않는 이유는 드라이버들이 이해하는 명령어가 있기 때문에 그럼(오브젝트 파일로 컴파일). 드라이버에 따라서 컴파일러가 다름. 이런 중간단계를 거치면 호환성도 좋아짐+개발효율을 좋게함(오브젝트 파일만으로 컴파일 하면 되니까). exe는 bat의  gui 버전임. 깔쌈하게 보임. 윈도우랑 리눅스 메모장의 인코딩 형식이 달라서 엔터를 엔터로 인식하지 못하기도함.  
  질문 : 인스톨할때 파일들 뚜르룩 나오는데 이건 컴파일 되고 있다고 하는거지. 데이터도 컴파일되는건가? 네. 그렇데요. 그런데 데이터도 같이 복사까지 해서 옮겨줌. 
인코딩은 약속된 형식 하나만 변환하는거. 컴파일러는 다양한거 전부 번역해줌. 
에디터와 IDE는 다름. 컴파일러는 프로그램을 만드는데 사용됨. vscode는 에디터임. 컴파일러는 추가 설치받아야됨. 그거 안하면 메모장이랑 같음. 
컴파일 할줄 안다 : 쉘에서 파일썬 경로 쳐서 컴파일하는거임. 
휴먼 에러를 줄이기 위해 컴파일 과정을 배움. 플레이 버튼만 누르면 에러 뜰 수 있으니 과정을 알아야함. cpu바꿔서 아키텍쳐 바뀌어도 컴파일 되긴 하는데 호환이 안될수도 있음. 
가끔 에러나는 cpu 번호가 있음. 왜 그러냐면 옛날 명령어(32bit)가 있는 파트를 검수하지 못해서 그럼. 거기에 에러나는 경우지. 

ssh 프로토콜이란? 규약(프로토콜) 통신들은 모두 프로토콜로 통신함. 이거만 맞추면 통신가능. 프로토콜 형식을 맞춰야됨. 옛날엔 ssh 대신 telnet도 있음. www도 있음. http도 프로토콜임. 인터넷 접속할려면 주소가 있어야됨. 주소는 ip address(host. 주인)임. port : 인터넷선 번호(항구). 항구에 선착장(host)이 여러개 있고. 포트는 선착장임. 포트가 여러개라면 데이터를 패킷으로 나눠 대역폭에 맞춰 보냄. 배가 쪼개져서 선착장에 도착한다는 것과 비슷함. well known 포트도 있음. 이런 포트는 전용 프로토콜이 있음. 21,telnet, FTP 는 프로토콜임. 22;ssh,FTP... 이렇게 포트마다 프로토콜이 나뉘어져있음. 대충 이렇다고. http? ssh? sftp? 뭐지?
telnet, ssh는 shell에 접속할 수 있는 프로토콜. 21번 포트가 쉘에 접근가능. 22번은 보안된 쉘. FTP, SFTP 명령어 주고받고 데이터 주고받고 가능한 프로토콜 파일 트랜스퍼 프로토콜임. 파일에도 접근할 수 있음. gui(그래픽유저인터페이스), cli(커맨드 라인 인터페이스). 주소도 ipv4, ipv6 로 나뉨. 비트수 차이임. 32, 128비트. v4는 주소가 4자리. 255.255.255.255 이렇게. 모든 컴퓨터엔 주소가 있음. 이 주소 할당이 거의 다 되면 v6로 쓴다. 사설 아이피(하마치)는 내부에서 사는 사람만 쓰고, 공인 아이피는 어디서든 통용 가능함. 192.168.0.1은 아이피타임 주소임. 1~255까지 연결가능함. 누구는 2번, 5번쓰는 식으로. 사설 아이피는 같은 공유기 써야 사용가능함. 공인 아이피는 월 15만원쓰면 부여해준데. 이건 국가별로 관리해서 그렇게 많이 못받음. 그럼 아이피는 뭐 어떤거 받아써? 이러면 ww.~.co.kr 같은 도메인사용함. 도메인이랑 우리가 쓰는 ip랑 연결할 수 있음. DNS(도메인 네임 서버) 가 연결해줌. 도메인은 산 사람이 가지고있음. 소유권자가 등록되어있음. DDNS는 공유기가 공유기 ip 주소 바뀌어도 도메인을 계속 연결할 수 있게 해줌. 다 있는 기능인데, 해킹위험이 있음. 그래서 사설 아이피를 써도 외부에서 접속이 가능함. 도메인 이름처럼 되어있기 때문. 그거만 알면 다른 컴으로 주소쳐서 접속가능. 포트포워딩도 있음. 다른 포트에서 오든 데이터나 전달을 특정 포트에 넘기도록 하는 기능. 보안이 좋아짐. 특정 포트에 넘기는데 그 포트를 막으면 땡이기 때문. TCP는 양방향(카톡 서버같은거씀), UDP는 단방향(스트리밍 좋음). ssh는 TCP를 씀. 도메인은 문자열로 이루어진 주소, ipaddress 는 숫자로 이루어진 주소. MAC도 있음. 이건 그 컴퓨터에 있는 고유 아이피임. 이 mac을 스캔해 무료 와이파이 쓸 수 있게함.
ssh 확장자를 vscode에 설치해야 원격 가능함. win scp는 연결프로그램이지. 뷰어같은거. 이런 지식을 알아야 원격으로 서버에 접속해 통신이 가능함. 

우리쓰는 서버 이름은 리눅스임. 사실 리눅스는 커널 이름임. 우분투 커널을 이용함. 리눅스 커널써서 만든 운영체제지. CLI 사용함. 텍스트 이용하는거임. 리눅스 서버는 서버를 끄지 않아도 업데이트가 가능하다는 장점이 있어 사용함. 모놀리식 커널은 윈도우에 사용함. 한번에 커널을 부팅함. 속도가 빠른데 섯불리 못건들이지. 리눅스는 모듈식 커널을 사용하기에 모듈만 수정하면 서버 안꺼도됨. 게다가 오픈소스가 돈이 안들고 서버용으로 개발이 잘되어있음. 그러니까 공짜에 개발도 편하고 서버 업뎃할때 서버 재부팅 안해줘도 된다는 장점 때문에 씀. 만약 딥러닝한다, 서버관련이다, 그러면 리눅스마스터 자격증도 좋다. centos 로 시험을 본데. 그러니까 리눅스 명령어 기능 관리도 다 암기해서 시험해서 합격하면 자격증 나옴. centos는 서버 관리에 용이함(근데 옛날에 유료임), 우분투는 옛날부터 무료라서 자료가 많기에 우리가 우분투를 사용함. centos는 rpm에다가 csh, 우분투는 apt에다가 bash을 씀 설치관리자(rpm, apt) 사용함. 사실 둘의 차이가 별로 없음. 오픈소스가 엄청 큰 장점이지!

우분투 터미널엔 User@server... 이렇게 씀. 서버는 컴퓨터 이름. 유저는 사용자이름. 이게 배쉬쉘임. 인터프리터 형식임. 한줄엔터쳐서 입력함. sudo는 임시로 관리자 권한을 명령어에 줌. su 치면 root#server로 바뀜. root#이 슈퍼유저란 뜻임. 왜 sudo써서 쓰냐? 시스템 파일 건들일 수 있어서 시스템 파일이 날라갈 수 있기 때문에 임시적으로 sudo로 권한 줘서 다루도록 함. 리눅스는 '/'에서 시작해서 /home/user/file...이렇게 감. 윈도우는 \(역슬래시) 사용함.  절대경로는 /home/a/file1 같이 경로를 전부 적어줘야됨. 상대경로는 a/file1 이렇게 씀. 유저가 home/~ 이렇게 되어있는거, 즉 내 위치(디렉토리) 기준으로 썼음. .은 하위 디렉토리, ..은 상위 디렉토리를 의미함(많이 봤을거야). ~은 내 home 폴더. _은 뒤로가기임. cd(체인지디렉토리)는 이동. 명령어 규칙 : cp -r -v  '-'은 옵션임. 인자들은 띄워써야됨. cp -r -v a b a에서 b로 복사. ls(리스트)가 폴더랑 파일들 보여줌. 요즘엔 ll(자세하게보기)씀. 이러면 현재 디렉토리 목록을 보여줌. ll /home/a 하면 a폴더 내의 모든 파일들을 보여줌. mkdir(디렉토리 만들기). mkdir -p a/2/k 하면 없는 경로에 있던 디렉토리 전부 만들어줌. rmdir(디렉토리삭제) 이건 bin파일만 지워주는 요상한 명령어임. rm은 삭제임. 그런데 디렉토리 내에 폴더나 파일 있으면 안먹힘. 그러니 재귀를 뜻하는 r 붙여서 하위디렉토리까지 삭제함. rm -r /home/a 하면 됨. -f는 강제임 쓰지마. sudo -rf /* 이거 강제로 전부 삭제임. touch는 파일 만들기. mv a b 하면 a에서 b로 이동임. mv /home/a.txt /home/b.txt 하면 이름이 a에서 b로 바뀜. cp -r 은 하위 디렉토리꺼까지 전부 복사함. nano a.txt or vim a.txt는 텍스트 편집기 여는거임. 없으면 만들고. top은 작업관리자(쓸데없음). nvidia-smi는 gpu사용률 보여줌(그 순간만). watch -n 1 nvidia-smi 하면 1초마다 사용량을 보여줌. which python 하면 파이썬 환경변수 위치 보여줌. greb은 검색. 명령어 결합해서 써야하는 반쪽짜리 명령어임. ls - l | grep s 하면 ls 결과를 받아서 s로 시작되는거 보여줌. 있는 기능 많으니 검색해서 찾아보자. sudo apt update,upgrade, remove 패키지이름, purge 패키지 이름, install 패키지이름... 명령어 무수히 많아서 외우기보다는 검색해서보기.  