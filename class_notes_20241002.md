내장함수랑 고급기법들을 배움. 웬만하면 이번 주 금요일까지 파이썬 끝남. 

이전에 낸 과제 고찰
조건은 다 맞춰서 만들었어. 만족해. 편각이랑 절대값은 그럭저럭 만족한다. 복소수 사칙연산도 만족해. 다만, 좌표계 변환은 시간이 없어 그리 좋게 만들지는 못했다. 아쉬움이 남아. 키워드 초기값도 제대로 못맞춰줬거든. 생각하고 짜야하는데 그냥 막 짜버렸어.
그러면 어떻게 해야할까? 먼저 아쉬웠던 점부터 적어보자
좌표계 전환을 부실하게 만들어서 아쉬워. 초기값 설정이라던가 예외처리라던가 버그가 발생할 것 같아.
readme.md 랑 라이센스, setup.py 같은 부가 과제들을 시간이 촉박해 왜 만드는지, 이것들이 무슨 의미가 있고 어떻게 사용되는지 더 알지 못해서 아쉬워. 정확하게 알게되었으면 좋겠어. 일단 막 만든터라 집어넣은 내용이 어떤 거인지 잘은 모르거든.
문서화도 내용이 부실한 것 같아 아쉬워. 주석은 더 달아두면 좋았을 것 같아.

그러면 내가 이 아쉬움들을 해결하고 만족감을 느낄려면 어떻게 해야 할까?
먼저 함수를 만들기 전에 한번 의사코드를 짜서 어떻게 돌아갈지 생각해보자. 그러면 대충 어떻게 짜야할지 눈에 보이니까 코드 작성에 부실함이 적어질거야. 또한 조건문이나 버그가 발생할 경우도 직접 적게 되니까 생각만 하다가 발생하는 버그가 줄어들거야. 강사님의 가르침을 따르자.
각종 파일들의 의미같은 것들은 시간이 답이겠다. 내가 이해할 수 있는 자료를 인터넷에서 찾아 노션에 정리하거나 그 파일속에 링크를 넣어 뜻을 이해하는데 시간을 할애해 보자. 그러면 나중에 github에 올릴 때 내가 대체 뭘 하고있는지, 그 파일의 사용법을 정확히 숙지하고있어 의문이 생기지 않을거야. 그리고 다른 사람이랑 협업을 할 때 다른 사람들이 내 코드를 이해하는데 효과적일거고.
문서화같은 경우는 사람마다 제각각인 경우도 있지만, 인터넷에도 한번 찾아보면서 자신의 문서화 형식을 만들어봐야겠다. 나도 이런건 할수있거든. 문서화를 반듯하게 하게 된다면 내 코드의 이해도가 높아져 코드 작성에 도움이 될테고 다른 사람들도 내 코드를 잘 사용하게될거야. 

복습
모듈 : 클래스들의 집합, 파이썬 파일 하나, 
패키지 : 모듈들의 집합, 생성자가 포함되어있음. 패키지에서 생성자(init.py)는 길잡이를 말함. 각 폴더마다 써움으로써 이 폴더는 패키지다 라고 선언해줌. 생성자 안써도 되는데, wheel이란 내장함수에 경로만 적어주면 알아서 만들어주기 때문임. 그런데 왜 생성자를 포함하는게 좋다고 하느냐? 상위폴더에 있는 파이썬 파일 import 할려하면 import ..printA.py 이런식으로 점 두개를 받아야됨. 오류가 나기도 하는데 왜 그러냐? 터미널에서 사용자 위치가 요상한데 잡혀있기 때문임. 터미널의 사용자 위치를 잘 봐두어야됨. 요즘엔 이렇게됨. 이걸 방지하기 위해서는 생성자(init.py)에서 경로를 초기화 하는 방법이 있음. 내가 상대위치를 파이썬 코드로 줄수있음. os.chdir('경로'). 이걸로 경로를 바꿀수있음. os.pwd() 하면 지금 내 위치 경로를 출력함. 이해못할 수 있는데, 터미널 위치 기준을 잘 보기. 주피터노트북은 위치가 이상한데 잡힐 수도 있으니 상대경로는 자제해야할것. 쓸거면 os.chdir()쓰기. 터미널 기준인데 자기 위치 잘 알아야됨. 이런걸 왜 말하는가? 경로를 지정해줬는데 안되. 알고보니까 폴더이름이랑 파이썬 파일 이름이 똑같아서 폴더를 찾을지, 파이썬 파일을 찾을지 분별을 못하기 때문임. 웬만하면 파일 이름은 복수형으로 하고 폴더는 단수형으로 쓰기. 
요약 : 생성자는 없어도된다. 생성자를 import os / os chdir 로 시작경로 지절해줄수있음. wheel 파일은 알아서 경로 다 지정해준다.

예외처리는 왜 하느냐? 에러가 나도 계속 돌아가야 하는 코드면 예외처리해야됨.
예외처리는 try: ,except: 문임. try 속 코드 돌다가 오류가 나면 except 내부 코드 실행함. 어디서 유용하냐면 아까전처럼 에러나도 돌아가야하는 프로그램에서 씀. 패키지에는 워닝, 에러가 있음. 둘 다 에러로 봄. 구버전 코드를 try에 쓰다가 오류 발생하면 expcept에 신버전 코드를 돌리는거지. except 발생오류 as 발생변수(e,a,b,...): 하면 특정오류를 오류변수에 담아라. except: 는 모든 오류를, except 발생오류: 지정한발생오류 출력한다. 이거 과제에서 나왔어! 주로 print('original error :' . e) print('설명:~~'). 대체로 except: 구문만 잘 씀. 
요약하면 예외처리는 구버전,신버전 업데이트때, 계속 돌아가는 코드에서 잘 쓰인다. else: 는 지정한 오류 외의 모든 오류를 출력하라는 의미임. 이걸 자세하게 쓸수록 전문가지.  

일부러 에러를 만들어 쓰기도함. raise ErrorofError 하면 ErrorofError를 반환함. 예시로 def errors(): raise erroroferrors 하면 errors() 하면 에러문 출력함. 왜 쓸까? 예시를 들자면, 만약에 함수를 만들었다 치자. 이렇게 만들었으면 에러가 나야 정상일때 혹은 내가 만든 클래스를 남이 오버라이딩 할 때 이건 쓰지마라 라고 예외를 만들어 두는거지. 테스트용도로도 사용하기도함. 

예외도 만들어 쓸 수 있음. 클래스로 씀. class 이름(Exception): 예외를 상속받아서 씀. 매서드를 def __str__(self) return "에러발생" 이렇게 씀. raise랑 다른점은? raise는 에러라는 클래스만 올수있음(zerodivisionerror 같은 에러 클래스 구문). Exception으로 만들어서 쓰면 에러를 직접 만들어서 쓸수있음. "에러발생' = e로 감. 

1. 에러는 class다!
2. 에러만들때 exception이란 클래스를 상속한다.
3. 에러 결과함수는 __str__함수를 오버라이딩한다.
4. raise 옆에는 에러 클래스만 온다.

예시

def setname(이름):
    if 이름=="욕설"
        raise name

class name(Exception)
    def __str__(self)
        return "욕설쓰지마"

try:
    A = setname(바보)
except:
    name as e
        print(e)

결과 : 욕설쓰지마

문법이라 그냥 그런거임. 에러 발생은 언제든지 달라질 수 있어 거의 마지막에 쓰임. 파이썬 2->3 넘어갈 때 바귀었데. 
이런 예외처리는 if문의 한 종류라고 생각하면됨.