복습

이전에 github, docker 배움
VCS= Version Control System
git - distribute. 분산형. 로컬 레포지토리(내 컴퓨터 저장소)에 저장한걸 서버에 저장하는 형식.
SVN - central. 중앙 집중형. 중앙에 데이터를 저장함
만약 같은파일의 같은 줄을 다른 사람들이 각자 바꾸고 푸시하면 충돌이 발생함. 이 충돌은 admin(관리자)가 관리함. 병합에서도 이런 일이 발생함. branch=version 이라고 생각하면 편함. 같은 파일 고치면 병합은 하지 말 것을 추천함. 이것이 분산형
중앙 집중형은 남들이 짜고있는 코드가 실시간으로 변함. 남의거 건들면 방해되니 조심. google docs나 replit같은 경우임
git은 VCS(명칭)을 통제하는 프로그램임. 
working directory      staging area    local repo      remote repo
 내가쓰던 폴더          변경점 추적     변경점 기록
 (git init)             (git add)      (git commit)

 git add 경로(폴더안에꺼). 
 config는 기본설정에 가까움.
git init 만 하면 branch version : master
git branch : branch 목록 출력(*초록줄 : 내가 작업중인 분기)
git checkout : 분기 변경
branch들은 독립적. 서로 영향 안미침. 
git merge는 branch들 통합하는 명령어. git checkout master -> git merge test -> test가 master에 병합
git add remote github주소
git push origin master -> 로컬 리포의 마스터를 원격 리포의 오리진에 밀어넣는다.
git push testa master ->
참고로 처음 리포 푸시할때 원격 리포가 빈공간이어야함. 조심해야됨. 
git clone : 모든 정보 복사해서 리모트->로컬 리포 붙여넣음
git fetch : 특정 버전(분기)만 받아옴
git pull : 특정 버전을 작업공간에 가져와서 갱신함. 

도커는 가상머신(OS)이다.
리눅스에선 커널 옆에 도커 엔진이 붙어서 같이 동작함(native). 도커 엔진 위에 컨테이너들을 여러개 생성한다고함.
윈도우에선 윈도우 커널 위에 도커 엔진이 부착됨.
이미지는 머신의 압축파일임. 이미지는 레이어들로 이루어짐. 레이어들은 변경된 것들을 저장한 거에 불과함. 커널 레이어, gui 레이어, 프로그램 레이어 등이 합쳐져서 이미지가 됨. 만약 서로 동일한 레이어가 있으면 동일한거 다운안받아도 되는 편리성이있음. run 돌리면 컨테이너 나옴
컨테이너는 이미지 압축 푼거.
도커파일은 이미지를 만들어주는 쉘 스크립트임(쉘 명령어 집합). 코드 한줄 한줄이 레이어가됨. 도커파일 실행하면 이미지생성됨.
도커허브에 도커파일들이 모여있음.
docker pull : 도커파일 가져옴
docker run --name test -it --gpus all --shm_size --DB --folder --port ... pythorch:2.4.1
        컨테이너 이름 설정  GPU 전부 사용                                   이미지 설정
                    인터렉티브. 터미널과 연결
옵션들은 도커허브 보고 찾아서 설정하면됨.
docker ps : 실행중인 컨테이너 보여줌 (-a 추가시 전부 보여줌)
컨트롤c 하면 컨테이너 죽일수있음.
docker start test : test 컨테이너 실행.
docker exec : 터미널로 명령내릴수있음
docker attach test /bin/bash: 터미널로 계속 연결


교재내용:
https://www.notion.so/planet-ms/VCS-feat-git-github-bb27f4eb660e49608f84e37005dd9015


수학을 배울 것임. 필요한 부분만 배울 것임. 함수, 미분, 행렬&벡터, 확통
주교재는 기초수학 파이썬, 파이썬 넘파이책
정의가 중요하다. 그리고 예제를 풀어본다. 정의가 중요해!!!! 미분이 뭔지 뭐 이런거.
확통은 수학보단 데이터과학에 가까움.

'수'에 대해서 부터 출발함. 함수의 관계를 보기 위해선 수의 정의를 알아야함.
수는 숫자를 말함. 정수(양수,음수,0), 자연수(양수), 유리수(유한히표현되는수), 무리수(무한히표현되는수), 허수(i)
직선에서 수는 무한함. 직선이 숫자로 된 점으로 무한히 이어져 합쳐진 것이기 때문. 직선 무한히 쪼갤 수 있기에 수도 무한함.
극한은 어떠한 값에 끝없이 다가간다면 그 값에 도달한다고 가정함.
디지털 : 0과 1로 된 이산적인 값(불연속). 서로 떨어진 값을 말함. 대충 점으로 표현됨. 아날로그 값을 쪼갠것. ADC란 것이 있음.
아날로그 : 연속적인(무한) 값. 대충 선으로 표현됨.
아날로그를 쪼개서 샘플링. 아날로그 이산화를 샘플링이라고함. 나이키스트 주파수는 샘플링을 어느정도 해야지 적절한가를 정하는 주파수.
헤르츠는 1초동안 1주기 가는 횟수를 말함. 촘촘함의 정도임. 진폭은 1주기의 (최대-최소)/2. 헤르츠로 정보를 전달할수있음. 주기로도 정보를 전달함수있음.
라디오 AM, FM 참조. 주파수 변조같은거. 진폭 변조 이렇게 나뉜거.
이건 왜 알아봤는가? 사진인식할때 픽셀로 함. 이건 이산화되어있음. 한 픽셀이 0~255값 가짐. 픽셀당 값도 이산화됨. 디지털로 학습이 되긴함.
유성음과 무성음으로 음성이 나뉨. 유성음은 성대 진동으로 나옴. 진동따라 소리가 달라짐. 유성음은 진동이 달라짐. 무성음은 성대떨림이 없어 진동이 안달라짐. 진폭(무성음)과 주파수(유성음) 조절해 음성을 만들 수 있음. TTS원리. 함수와 같은 기능을 함(글자입력->음성출력). 인풋과 아웃풋이 있으면 함수다! 수는 무한하다, 디지털로 표현하자면 이산적으로 표현해야한다. 컴퓨터는 디지털이라 값이 이산적일 수밖에 없음. TTS도 미적분으로 표현함. 음성을 쪼개서 샘플링(미분)하고 이어붙임(적분). 무한히 하면 원본으로 복원할 수 있다는 개념임. 무한히 나누는데 결과값이 얼마지?? 그런데 이거 정의가 기울기랑 같네? 그럼 기울기라고 하자. 변화량은 크기임. 즉, 스칼라값임. 스칼라+방향=벡터. 이건 왜 배우나? 함수에서 우리가 가고자 하는 방향을 알 수 있기 때문(경사하강법). +-로 방향표현. 행렬은 계산을 빠르게 하기 위한 방법임. 표현도 쉽게가능. 컴퓨터는 다중계산에 효율적이라 선형대수(행렬)씀. 어떻게 효율적으로 빠르게 값을 계산하는 것이 선형대수. 벡터도 행렬로 표현가능. 계산도 쉽고. 그걸 numpy가 해줌. 선형대수 값 구하는 방법들 다 쑤셔박은거임. 데이터셋도 행렬로 표현할수 있기에 벡터라고 볼수있음. 행렬값 하나마다 다 특징임. RGB에서 조합해서 검정색이 나오면 그게 특징임. 검정색을 RGB로 쪼개면 특징을 분해한것(CNN). 필터 먹이는 것도 콘볼루션으로 계산가능함(특징분해가능. 가로세로줄 뽑아낼수있다. 그 이상도 가능!).

복소수는 허수 차원에서 음수에 해당함. 

기초수학이랑 넘파이책 읽어봐 그거 기초로 수업하고있거든. 