virtualenv는 파이썬 자체 제공 가상환경임. 이거 왜 필요한가? 작동원리에 파이썬 복사가 있음. 파이썬 인터프리터의 경량 복사본을 생성함. 원본 파이썬을 건드리지 않음. 다만 복사본의 환경변수를 지정해줘야됨. 이러면 복사본을 쓰게됨. 콘다도 activate로 복사된 파이썬 인터프리터 환경변수 지정해주는거임. 치명적인 단점도 있음. 원래 복사할려던 파이썬 폴더가 깨끗해야됨(쓸데없는거 없어야됨. 안그럼 그것도 달려옴). 라즈베리는 virtualenv를 권장(가벼움, 공식지원). 장점 : 가벼움, 파이썬만 설치되면 어디서든 사용가능(임베디드). 참고로 이것도 그냥 파이썬 폴더 복사를 자동으로 편하게 해주는거임. 참고로 파이썬이랑 pip는 다른 프로그램임. python.exe, pip.exe. 다른 실행 명령어 사용함. pip도 파이썬 폴더 라이브러리에 설치를 쉽게할수있도록 도와주는 프로그램임(파이썬인). 이걸 왜 설명하냐면 가끔 pip 안될수있어서 그럼. 그러면 대용으로 setuptools 써야됐고. 옛날엔 파이썬 깔고 pip도 깔아야됐음. 구체적인 예시 부분을 잘 보기. 현재 위치에 프로젝트 이름 폴더를 생성함. source(shell 실행)를 써서 가상환경 활성화함(프로그램에서 적용한다는 개념임). 내가 만든 가상환경 프로젝트를 쓰겠다고 적용하는거임. activate는 현재 터미널에 적용되는거. acti폴더 안에 가상환경 경로가 들어가있어 그걸 환경변수로 설정한다는 뜻. 참고로 .fish 는 평션쉘이란 뜻. virtualenv로 파이썬 설치하면 몇MB밖에 안될정도로 엄청 가벼움(다른패키지 많이 안깔면). 아나콘다는 수백MB~몇GB됨. 독립적인 가상환경 설정에 필요하다고 생각하기. 참고로 리눅스 파일system 중에서 .py로 관리되는 파일이 있어 우분투에선 파이썬 삭제불가능함. 특히 GUI를 파이썬으로 만들어서 개떡같고 느리데. 재현 가능한 개발 환경 = 백업되는 환경. ">" 는 왼쪽 코드 결과를 오른쪽 코드에 저장하는거. "-r"는 반복이란 의미로 백업 텍스트 파일의 리스트에 저장된 정보를 하나하나 반복해서 설치하는거임. -r 안적으면 에러뜸. 사실 폴더이름쓸때 -r 적어야 에러안뜸. 4클린 테스트 환경 사용에서 파이썬 버전이 시스템에 깔려 있어야 설정가능함. 3.9깔아야 3.9쓸수있음. virtualenv도 버전마다 깔려있어야됨. 패키지 목록 들어가있는 폴더 이름 아무거나 써도 되는데 requ.txt가 국룰이 됨. virtualenv 환경이름(which python 으로 나온 버전으로 설치권장). 3. 시스템 사이트 패키지 포함이 굉장히 중요함. 시스템에 설치된 패키지들을 가상환경에서 사용할 수 있게 하주는 명령어임. 라즈베리파이에서 사용하기 때문에 중요하다! 라즈베리에 깐 패키지를 가져오는게 거의 불가능한데 그걸 해줌. --system-site-package 커맨드 기억하기! 윈도우에선 bin 대신 scripts 폴더가 생성되거 거기에 파이썬이 위치함. 참고로 폴더나 파일이름 지을때 공백쓰지마라 오류난다. 가상환경삭제는 그냥 그 폴더 삭제하면 끝! github에서 설치도 가능함(git저장소안에 setup.py 있어야 가능), 로컬 파일에서 설치도 가능(wheel, 압축파일 설치도 도와줌), 의존성 무시하고 설치도 가능(권장안함). "-p" 는 경로 약어. 폴더 별로 가상환경이 저장되어 관리하기 편함. 파이썬만 있으면 되기때문이다. 

setuptools은 파이썬 패키지를 빌드(환경맞는컴파일러선택), 배포, 설치할수 있게해주는 라이브러리임. 그러니까 wheel 파일 만들어줌. 이걸 더 쉽게할려고 pip가 나옴. setup.py(국룰로 굳어짐. 관례) 파일로 패키지 설치가능. 이거 내가 실습해본거임. 계산기 마지막 ex과제임. 의존성 라이브러리는 한 라이브러리에 필요한 라이브러리가 있을 때 말함. 적어줘야 의존성 관리가 쉬움. 안그럼 하나하나 버전까지 알아서 다 설치해야됨. setuptools는 라이브러리 하나만 설치하기 때문에 의존성 관리가 어려운 라이브러리임

pip는 pypi.org 에서 내려받음. 패키지명==버전, 콘다는 패키지명=버전 이렇게 버전을 설정함. 


서버 콘다 재설치할거니까 백업해두기. 하는법... 알지?

https://www.notion.so/planet-ms/virtualenv-25a073493eed49a1ac5cedb795b4cd67

콘다는 의존성이 매우 좋아 버전에 맞게 잘 맞춰줌. 관련된 모듈도 다 깔아주고. pip는 안그래. 패키지 달라서 생기는 오류를 고려하지않아. 최신버전을 깔아주거든. 이걸 예방할려면 pip install pythorch numpy 이렇게 같이 깔라고 하면 맞춰줌. 참고로 콘다는 라이브러리 관리 프로그램 자체가 무거워서 용량 많이 나가는거. 콘다에 virtualenv 쓰면 경로 에러가 뜰 경우가 뜰 수 있음. 콘다 가상환경 삭제는 conda remove -n test --all 로 전부 삭제해야 편함.

리눅스 (base)~는 shell 마다설정되어있는거임. 

굳이 콘다 말고 가벼운 virtualenv 써도됨. 
아나콘다 : 프로그램. 패키지 설치 + 의존성관리. 무거움
virtualenv : 라이브러리(=패키지). 패키지 설치. 가볍고 기본 라이브러리라 설치안해도됨



도커파일 : 이미지 생성용 쉘 스크립트임.
도커파일의 철학적 기반 : 불변 인프라스트럭처(컨테이너 생성하면 변경말라, 변경한다면 새 이미지 써라), 코드로서의 인프라(인프라 구성을 버전 관리 가능한 코드로 정의, 가상환경+VCS로 관리해라), 계층화된 파일 시스템(중복된 레이어 다운 안하는 효율성때문)
도커파일특징 : 텍스트 기반. 자동화 지원(git)

FROM golang:1.16 -> reposctory:tag. AS builder. FROM은 무조건 처음에 와야됨(FROM 두번쓰면 오류남).

도커파일은 반드시 "Dockerfile" 이란 이름으로 도커파일생성. 그렇게 생성하면 고래 아이콘뜸. 이것도 폴더 만들어서 넣어둬야 중구난방으로 파일 생성되는걸 막음. 한 폴더당 1개의 도커파일이 존재함을 주의할것.
FROM "기본이미지" -> 도커허브나 로컬저장소의 이미지파일을 가져옴. 로컬부터 찾아보고 없으면 허브에서 가져옴
ADD "이미지에 추가할 파일"
RUN "실행할 명령어" -> 터미널에서 쓰는 명령어와 동일
WORKDIR -> 시작지점이 어디냐 표시. 도커파일 다운받아 보면 시작지점이 있음. WORKDIR이 그 시작지점을 표시함. RUN하면 내 위치를 시작지점으로 옮겨줌.
COPY -> 현재 경로에 있는 파일을 추가함. (COPY (source로컬머신현재경로) (dist가상머신목적지)). 
CMD -> 도커파일내 한번만 사용가능
build -> 도커파일을 이미지로 만드는 명령어. 시간 수서에 맞게 만듬(위->아래). 중단되면 처음부터 다시 시작해야됨. 설치시간 오래걸릴수도있음.

FROM RUN COPY WORKDIR 을 자주 쓰고. EXPOSE는 컨테이너에 들어갈 포트를 지정함.

인프라스트럭처 AS 코드(IaC) : 인프라(OS)를 코드(도커파일)로 관리한다. 우분투깔고 돌리는 코드를 도커파일로 하는거지. 들어본적은 있다!

COPY . . 은 현재 도커파일있는 폴더에 있는 파일들을 가상머신폴더에 붙여넣는명령어. 

FROM ~ AS는 빌더만 하나 빼온거.
FROM 그냥 써야 이제 이미지 파일 생성됨. 

도커파일 순서(코드). 한줄한줄이 레이어임.
FROM
WORKDIR
COPY
RUN
COPY
EXPOSE
CMD

5000번 1버전을 5001번 2버전을 5000으로 포트포워딩 해서 2버전 잡게하고 1버전 죽이면 됨. 서버세팅이 중요함. 도커도 나중에 프로젝트 할 때 사용할 것임. 나도 사용해야겠다.  

넘파이 - 선형대수계산 라이브러리 - 행렬 연산함 - 방정식 푸는데 효율적임]
행렬은 벡터, 스칼라 표현하고 좌표계도 표현할수있어서 씀.
PLT.SHOW는 GUI에서만 가능. 주피터 노트북 .ipynb 에서 가능
convex 컴백스 = 볼록 = 모든 두 점(직선) 사이에 만나는 점이 없다(어디서든 직선 그어도 만나는 점이 2개다!)-> '최솟값이 1개 존재한다' 란 의미
오차 평균 구할 때 왜 2를 나누나? 몰?루
역삼각형은 그레디언트 기호. 라운드 기호는 편미분 기호임.
수학공식들 어떻게 부르는가, 기호 이름인가, n은 에타, o는 라운드, 세모는 그레디언트
선형회귀는 어떤값을 넣었을 때의 예측값을 얻기위함.`
초기값은 최적값 찾는 속도에 영향을 미친다. 
머신 러닝은 모든 수에 대응되는 함수는 찾는 것임. 즉 입력을 무슨 값을 넣어도 어떤값을 출력해야함.
자연수 기호는 N. 무한하지만 셀수있음
정수 기호는 Z. 자연수 + 0 + 음수. int. 이것도 무한하지만 셀수있음.
유리수는 분자분모로 정수를 갖는 분수로 나타낼 수 있는수. 유리수 기호는 Q. 무한하지만 셀수있음. 
무리수는 분수로도 표현되지 않는 수. 규칙성 없음. 그래서 무한하고 셀수없음!.
실수는 무리수+유리수. 실수 기호는 R. 무리수가 포함되 무한하고 셀수없음.
함수는 입력과 출력의 관계를 지정함. 연관이 있느냐를 말함. 여기서 관계는 하나임. 출력이 여러개면 관계도 여러개라 함수라고 못부름. 그걸 확률이라고 하지 관계라고 안함. 값이 2개면 식도 2개임. 함수는 관계다. 일대일 대응을 한다. 출력이 여러개면 종속성이 없다고 판단되어 관계성이 없음을 의미함. 한개의 출력에서 한개의 출력만! 함수의 정의다!. X=입력=정의역=domain, Y=출력=공역=codomain 
직교 좌표계=데카르트 자표계= rectangular coordinate system = cartesian coordinate system
합의 기호=시그마
거듭제곱 = x^n
다항 함수 = +-가 여러개로 이루어진 식. 덧셈으로 연결되는 것들을 항. 변수에 붙은 숫자를 계수. 제곱횟수를 차수. 상수를 편향(bias)이라고도 함.
다차 함수 != 다항 함수. 서로 다른 개념임.
다차 함수는 최고차항 기준임. y= x^100 = 단항함수=다차함수
라텍스 문법은 코드로 계산식을 만들어줌. 
지수함수는 거듭제곱 꼴의 함수. y = a^x . 변수x가 차수에 위치함.  a=밑. 지수법칙이 중요함.
로그함수는 y=logax. 지수함수를 변형한것.